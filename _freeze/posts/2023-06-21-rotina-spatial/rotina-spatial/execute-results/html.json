{
  "hash": "b9e637807bb7f2ba499fe937639a9a03",
  "result": {
    "markdown": "---\ntitle: \"Rotina básica para dados espaciais no R\"\ndescription: \"Aprenda a baixar, filtrar e combinar dados\"\nauthor:\n  - name: Arthur Bazolli\n    url: https://baarthur.github.io/\n    affiliation: PPGE/UFJF\n    affiliation-url: https://www2.ufjf.br/poseconomia/ \ndate: 2023-06-21\ncategories: [R, Basedosdados, Tutorial, Português] # self-defined categories\ncitation: \n  url: https://samanthacsik.github.io/posts/2023-06-20-basedosdados/ \nimage: img/bd_logo.png\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\n\nexecute: \n  echo: fenced\n---\n\n\n# Introdução\n\nMuitos amigos me perguntam como fazer operações espaciais no `R`. Então, decidi criar essa rotina muito simples, com o mínimo para começar e algumas operações básicas.\n\nComo eu já disse no [post sobre a Base dos Dados](https://baarthur.github.io/posts/2023-06-20-basedosdados/): crie um R Project e seja organizado, ajude o você de amanhã! Ele vai agradecer.\n\n## Links úteis\n\n* A melhor referência que eu conheço para dados espaciais no R: O livro [Geocomputation With R](https://r.geocompx.org/).\n* Excelentes tutoriais também no [r-spatial.org](https://r-spatial.org/)\n* [geobr](https://ipeagit.github.io/geobr/): mapas brasileiros em alta qualidade no R!\n* [aopdata](https://ipeagit.github.io/aopdata/): Projeto Acesso a Oportunidades do Ipea, com base muito rica para download direto no seu R\n* [Geosampa](https://geosampa.prefeitura.sp.gov.br/PaginasPublicas/_SBC.aspx): portal da Prefeitura de São Paulo com diversos dados geolocalizados\n* [BHMap](https://bhmap.pbh.gov.br/v2/mapa/idebhgeo) e [IDE Sistema](https://idesisema.meioambiente.mg.gov.br/webgis): idem, para BH e o Governo de Minas\n* [Mapbiomas](https://mapbiomas.org/): nunca usei, mas é referência para o pessoal que trabalha com meio ambiente.\n* Shapefiles de ferrovias, rodovias, aeroportos, portos e mais no site do [ONTL/EPL](https://ontl2.epl.gov.br/downloads)\n\n\n\n# Setup\n\nDefina um bloco de código (`Ctrl` + `Alt` + `I`) para chamar os pacotes necessários. Use a opção `#| label: setup`, como abaixo, para ele sempre ser executado no começo.\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: setup\n\n# geral e tratamento de dados\nlibrary(here)\n```\n````\n\n::: {.cell-output .cell-output-stderr}\n```\nhere() starts at /Users/baarthur/Library/CloudStorage/OneDrive-Personal/Documentos/R/Projects/baarthur.github.io\n```\n:::\n\n````{.cell-code}\n```{{r}}\n#| label: setup\n\nlibrary(janitor)\n```\n````\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'janitor'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n```\n:::\n\n````{.cell-code}\n```{{r}}\n#| label: setup\n\nlibrary(tidyverse)\n```\n````\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n````{.cell-code}\n```{{r}}\n#| label: setup\n\n# operações espaciais\nlibrary(sf)\n```\n````\n\n::: {.cell-output .cell-output-stderr}\n```\nLinking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE\n```\n:::\n\n````{.cell-code}\n```{{r}}\n#| label: setup\n\n# bases de dados\nlibrary(geobr)\nlibrary(sidrar)\n```\n````\n:::\n\n\n\n\n# Carregando dados\n\n## Da internet\n\nVários shapefiles brasileiros estão disponíveis online. Alguns podem ser baixados direto no `R`, como o `{geobr}` e o `{aopdata}`. Nesse exemplo, vamos baixar o shapefile dos municípios mineiros usando o `{geobr}`:\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: download-shp\n\nshp_mg_muni <- read_municipality(\n  code_muni = \"MG\",\n  showProgress = FALSE\n)\n```\n````\n\n::: {.cell-output .cell-output-stderr}\n```\nUsing year 2010\n```\n:::\n:::\n\n\nSegundo o manual da função `read_municipality()` (digite `?read_municipality` no console ou vá em `Help` e digite o nome da função), podemos baixar só os municípios de um estado especificando o código do estado ou sua sigla em `code_muni`, ou ainda baixar apenas uma cidade especificando o seu código de 7 dígitos do IBGE.\n\nAdicionei, ainda, `showProgress = FALSE` para não mostrar o status do download enquanto baixa. Outra opção é `simplified = FALSE` para baixar o shapefile mais detalhado possível. Isso é muito mais pesado; na dúvida, não baixe.\n\n:::{.callout-info}\nÀs vezes, um shapefile \"dá pau\" na hora de fazer as operações que vamos ver lá na frente. Se isso acontecer, use a transformação `st_make_valid()` para consertá-lo:\n:::\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: make-valid\n\nshp_mg_muni <- shp_mg_muni %>% \n  st_make_valid()\n```\n````\n:::\n\n\n\n## Do computador\n\nNeste exemplo, vamos carregar dois shapefiles para fazer operações espaciais: a malha de municípios mineiros, no formato `.shp`, e um mapa ferroviário, no formato do Google Earth (`.kml`). Usando o pacote `{sf}`, carregamos os shapefiles com `st_read()`. Supondo que você tem uma pasta chamada `shp` dentro da pasta `data` com seus shapefiles:\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: read-mg\n#| eval: false\n\nshp_mg_muni <- here(\"data/shp/shapefile_minas.shp\") %>% \n  st_read()\n```\n````\n:::\n\n\n::: {.callout-warning}\nOs shapefiles do tipo `.shp` tem pelo menos quatro camadas, em arquivos separados: `.dbf`, `.prj`, `.shp` e `.shx`. Por mais que na função `st_read()` nós passemos só o `.shp`, ela está usando todas as camadas; logo, elas devem estar na pasta também! \n:::\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `Transmineiriana' from data source \n  `/Users/baarthur/Library/CloudStorage/OneDrive-Personal/Documentos/R/Projects/baarthur.github.io/posts/2023-06-21-rotina-spatial/data/shp/ferrovias.kml' \n  using driver `KML'\nSimple feature collection with 99 features and 2 fields\nGeometry type: GEOMETRY\nDimension:     XY\nBounding box:  xmin: -48.2703 ymin: -23.51613 xmax: -38.40762 ymax: -12.49129\nGeodetic CRS:  WGS 84\n```\n:::\n:::\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: read-ferro\n#| eval: false\n\nshp_ferrovias <- here(\"data/shp/ferrovias.kml\") %>% \n  st_read()\n```\n````\n:::\n\n\n::: {.fallout-info}\nNo Quarto (`.qmd`) e no RMarkdown (`.Rmd`), usamos a função `here()` do pacote homônimo para passar endereços relativos. Isso evita a bagunça que acontece com a dupla `setwd()`/`getwd()` e a chatice de ficar invertendo barras nos caminhos absolutos. Os endereços relativos são *relativos* à pasta origem do seu projeto, porque o R Project entende qur você está partindo dali.\n:::\n\n\n## Compatibilidade de coordenadas\n\nExistem diferentes padrões de coordenadas (**CRS**, de *Coordinate Reference System*): o mais comum é o WGS 84, usado nos GPS e no Google Maps. Mas, como a terra não é plana, alguns padrões são mais adequados para locais diferentes. No Brasil, mapas administrativos costumam usar o Sirgas 2000 e suas variantes. Por isso, temos ficar atentos se nossos shapefiles estão no mesmo padrão! Para verificar:\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: check-crs\n\nst_crs(shp_mg_muni)\nst_crs(shp_ferrovias)\n```\n````\n\n::: {.cell-output .cell-output-stdout}\n```\nCoordinate Reference System:\n  User input: SIRGAS 2000 \n  wkt:\nGEOGCRS[\"SIRGAS 2000\",\n    DATUM[\"Sistema de Referencia Geocentrico para las AmericaS 2000\",\n        ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"Latin America - Central America and South America - onshore and offshore. Brazil - onshore and offshore.\"],\n        BBOX[-59.87,-122.19,32.72,-25.28]],\n    ID[\"EPSG\",4674]]\nCoordinate Reference System:\n  User input: WGS 84 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]\n```\n:::\n:::\n\n\nNesse exemplo, a malha municipal usa o Sirgas 2000, enquanto o mapa de ferrovias usa o WGS 84. Como eu prefiro o primeiro CRS, vou transformar o seguno para que também fique em Sirgas 2000. \n\n::: {.callout-tip}\nCada CRS tem um código **EPSG** associado. No caso do Sirgas 2000 é o 4674, e para o WGS 84, é o 4326. Veja mais em [epsg.io](https://epsg.io/).\n:::\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: set-crs\n\n# Alternativa 1: modificar manualmente inserindo o CRS desejado.\nshp_ferrovias <- shp_ferrovias %>% \n  st_transform(crs = 4674)\n\n# Alternativa 2: modificar o CRS de X para que seja igual ao de Y.\nshp_ferrovias <- shp_ferrovias %>% \n  st_transform(crs = st_crs(shp_mg_muni))\n```\n````\n:::\n\n\n\n\n# Filtrar shapefiles\n\nSuponha que queremos filtrar as cidades que são artravessadas pela Estrada Real. Podemos fazer isso com o `st_filter()`. Mas antes, um resumo sobre as operações espaciais:\n\nO pacte `{sf}` contém uma série de funções que computam relações topológicas entre objetos espaciais (da classe `simple.feature`). Por exemplo: `st_intersects(x,y)` indica se `x` cruza `y`; `st_covers(x,y)`, se `x` cobre `y` e o contrário por `st_covered_by(x,y)` e assim em diante. Leia mais sobre essas operações no excelente [livro do Robin Lovelace](https://r.geocompx.org/geometry-operations.html) e no site do [PostGIS](http://postgis.net/workshops/postgis-intro/spatial_relationships.html), pois as operações realizadas em SQL são basicamente as mesmsas que o `{sf}` faz no `R`.\n\nEssas operações espaciais também podem ser usadas como predicado para filtrar ou juntar dados. Nesse exemplo, vamos usar o predicado `st_intersects`:\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\nshp_muni_ferro <- shp_mg_muni %>% \n  st_filter(shp_ferrovias, .predicate = st_intersects)\n```\n````\n:::\n\n\nO novo objeto contém 190 municípios: apenas aqueles atravessados pelas ferrovias contidas no `.kml`. Alternativamente, podemos só salvar o novo objeto em cima do antigo: `shp_mg_muni <- shp_mg_muni %>% (...)`\n\n\n\n# Combinar bases\n\nOutra operação poderosa no R é combinar informações de uma base com um shapefile. Nesse exemplo, vamos usar uma base de população municipal do IBGE para cruzar com o shapefile de cidades mineiras. \n\n\n## Baixando dados do IBGE com o SidraR\n\nO Sidra ---Sistema IBGE de Recuperação Automática--- pode ser acessado diretamente pelo R. Você pode tanto buscar termos específicos, usando `search_sidra(\"termo\")`, quanto baixar diretamente uma tabela que você já conheça. Vamos usar o exemplo completo: vou buscar informações sobre população.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: search_sidra\n#| eval: false\n\nsearch_sidra(\"população\")\n```\n````\n:::\n\n\nO resultado retornou mais de 90 tabelas. Como isso é muito confuso, prefiro ir no site do Sidra, ver a tabela que eu quero e baixar no R. No caso, quero a tabela `6579`. Vamos ver as opções disponíveis para ela:\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: info_sidra\n\ninfo_sidra(6579)\n```\n````\n\n::: {.cell-output .cell-output-stdout}\n```\n$table\n[1] \"Tabela 6579: População residente estimada\"\n\n$period\n[1] \"2001, 2002, 2003, 2004, 2005, 2006, 2008, 2009, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021\"\n\n$variable\n   cod                                   desc\n1 9324 População residente estimada (Pessoas)\n\n$classific_category\nNULL\n\n$geo\n     cod                      desc\n1 Brazil                Brasil (1)\n2 Region         Grande Região (5)\n3  State Unidade da Federação (27)\n4   City         Município (5.570)\n```\n:::\n:::\n\n\nDe posse dessas informações, podemos configurar a chamada da função `get_sidra()`:\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: get_sidra\n\ndf_pop <- get_sidra(\n  6579,\n  period = \"2021\",\n  geo = \"City\"\n)\n```\n````\n\n::: {.cell-output .cell-output-stderr}\n```\nConsidering all categories once 'classific' was set to 'all' (default)\n```\n:::\n\n````{.cell-code}\n```{{r}}\n#| label: get_sidra\n\nhead(df_pop)\n```\n````\n\n::: {.cell-output .cell-output-stdout}\n```\n  Nível Territorial (Código) Nível Territorial Unidade de Medida (Código)\n2                          6         Município                         45\n3                          6         Município                         45\n4                          6         Município                         45\n5                          6         Município                         45\n6                          6         Município                         45\n7                          6         Município                         45\n  Unidade de Medida  Valor Município (Código)                  Município\n2           Pessoas  22516            1100015 Alta Floresta D'Oeste - RO\n3           Pessoas 111148            1100023             Ariquemes - RO\n4           Pessoas   5067            1100031                Cabixi - RO\n5           Pessoas  86416            1100049                Cacoal - RO\n6           Pessoas  16088            1100056            Cerejeiras - RO\n7           Pessoas  15213            1100064     Colorado do Oeste - RO\n  Ano (Código)  Ano Variável (Código)                     Variável\n2         2021 2021              9324 População residente estimada\n3         2021 2021              9324 População residente estimada\n4         2021 2021              9324 População residente estimada\n5         2021 2021              9324 População residente estimada\n6         2021 2021              9324 População residente estimada\n7         2021 2021              9324 População residente estimada\n```\n:::\n:::\n\n\nE assim, baixamos a população de 2021 para todos os municípios brasileiros. No entanto, essa tabela do IBGE não está organizada da melhor forma pra processamento no R. Podemos melhorar removendo as informações desnecessárias (`select()`) e limpando os nomes (`clean_names()` e `rename()`) para compatibilizar com a outra tabela.\n\n::: {.callout-tip}\nUse os mesmos nomes para variáveis comuns nos dois objetos. Não é obrigatório, mas facilita sua vida; caso contrário, tem que especificar qual variável de `x` é igual a qual variável de `y` para dar o join. Como o shapefile do `{geobr}` vem com nomes padronizados, vamos adotá-la e modificar a base do IBGE.  \n:::\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: tidy-data\n\n# passo 1: limpar nomes (tirar maiúsculas, espaços e outras complicações)\ndf_pop <- df_pop %>% \n  clean_names() \n\n# passo 2: remover o que não precismos e renomear. Fazemos isso tudo junto com transmute, na sintaxe novo_nome = nome_antigo\ndf_pop <- df_pop %>% \n  transmute(\n    pop = valor, code_muni = as.numeric(municipio_codigo),\n    year = as.numeric(ano)\n  )\n```\n````\n:::\n\n\nAo usarmos transmute, estamos ao mesmo tempo renomeando as variáveis que querendo e removendo as que não estão ali. Note que também passei `as.numeric()` em `code_muni` e `ano`, pois estavam como `character.` No caso de `code_muni`, essa informação é numérica (`numeric`) na base do `{geobr}`, então ia dar erro no join; já no caso do ano, é porque facilita quando esse tipo de informação é numérica (por exemplo, para filtrar datas maiores do que `x`).\n\n::: {.callout-warning}\nA informação de nome do município **frequentemente** está diferente entre bases. Ex.: acentuação, hifens, etc. Para não dar erro, prefira **SEMPRE** usar o código em vez do nome; repare que até removi o nome da cidade e vou usar apenas o do `{geobr}`. Nesse caso, a base do IBGE tem a sigla do estado junto do nome do município, como \"Abadia dos Dourados - MG\".\n:::\n\n\n## Juntando: população e shapefile\n\nAgora é partir para o abraço. Vamos jogar as informações do IBGE no shapefile ---ou vice-versa; nesse caso (não é sempre), a ordem não importa.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: join\n\nshp_mg_muni <- shp_mg_muni %>% \n  left_join(df_pop)\n```\n````\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining with `by = join_by(code_muni)`\n```\n:::\n:::\n\n\n\n\n# Visualização\n\n## Mapa de municípios e população\n\nVamos plotar o mapa de Minas Gerais, colorindo de acordo com a população.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: basic-plot\n\nggplot() +\n  geom_sf(\n    data = shp_mg_muni,\n    aes(fill = pop)\n  )\n```\n````\n\n::: {.cell-output-display}\n![](rotina-spatial_files/figure-html/basic-plot-1.png){width=672}\n:::\n:::\n\n\nPodemos customizar esse mapa adiconando camadas e capadas. As duas mais importantes: uma camada para a escala de cores do `fill` (preenchimento) e outra para o tema.\n\nExistem duas coleções de paletas muito famosas: Brewer e Viridis. A primeira tem cores mais \"comuns\", mas a segunda dá um contraste muito bom. Abaixo, as paletas de cada coleção e a sintaxe (substitua `XXX` pelo tipo de `aesthetic` em uso: `fill`, `color` etc.)\n\n* Brewer: https://r-graph-gallery.com/38-rcolorbrewers-palettes.html\n  + Discreta: `ggplot() + (...) + scale_XXX_brewer()`\n  + Condtínua: `ggplot() + (...) + scale_XXX_distiller()`\n  + Binned: `ggplot() + (...) + scale_XXX_fermenter()`\n* Viridis: https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html\n  + Discreta: `ggplot() + (...) + scale_XXX_viridis_d()`\n  + Condtínua: `ggplot() + (...) + scale_XXX_viridis_c()`\n  + Binned: `ggplot() + (...) + scale_XXX_viridis_b()`\n\nExemplo com viridis\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: cool-plot-viridis\n\nggplot() +\n  geom_sf(\n    data = shp_mg_muni,\n    aes(fill = pop),\n    color = \"lightgrey\"\n  ) +\n  scale_fill_viridis_c(\n    option = \"magma\",\n    direction = -1,\n    name = \"População\", \n    labels = scales::comma_format(big.mark = \".\", decimal.mark = \",\")\n  ) +\n  labs(\n    title = \"População dos municípios mineiros em 2021\",\n    subtitle = \"Olha só que doido esse trem!\",\n    caption = \"Fonte: IBGE (2023)\"\n  ) +\n  theme_void()\n```\n````\n\n::: {.cell-output-display}\n![](rotina-spatial_files/figure-html/cool-plot-viridis-1.png){width=672}\n:::\n:::\n\n\nExemplo com Brewer:\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: cool-plot-brewer\n\nggplot() +\n  geom_sf(\n    data = shp_mg_muni,\n    aes(fill = pop),\n    color = \"lightgrey\"\n  ) +\n  scale_fill_distiller(\n    palette = \"YlOrRd\",\n    direction = 1,\n    name = \"População\", \n    labels = scales::comma_format(big.mark = \".\", decimal.mark = \",\")\n  ) +\n  labs(\n    title = \"População dos municípios mineiros em 2021\",\n    subtitle = \"Olha só que doido esse trem!\",\n    caption = \"Fonte: IBGE (2023)\"\n  ) +\n  theme_void()\n```\n````\n\n::: {.cell-output-display}\n![](rotina-spatial_files/figure-html/cool-plot-brewer-1.png){width=672}\n:::\n:::\n\n\n## Mapa de municípios e ferrovias\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: ferro-plot\n\nshp_br <- read_state(showProgress = F)\n```\n````\n\n::: {.cell-output .cell-output-stderr}\n```\nUsing year 2010\n```\n:::\n\n````{.cell-code}\n```{{r}}\n#| label: ferro-plot\n\nggplot() +\n  geom_sf(\n    data = shp_br %>% filter(abbrev_state != \"MG\"),\n    fill = \"grey85\",\n    color = \"grey60\"\n  ) +\n  geom_sf(\n    data = shp_mg_muni,\n    fill = \"grey95\",\n    color = \"grey85\"\n  ) + \n  geom_sf(\n    data = shp_ferrovias %>% filter(Name %in% c(\"BH - Nova Era\", \"Nova Era - Pedro Nolasco\")),\n    aes(color = \"EFVM\", linetype = \"Operando\")\n  ) +\n  geom_sf(\n    data = shp_ferrovias %>% filter(Name %in% c(\"Horto - Salvador\", \"Corinto - Pirapora\")),\n    aes(color = \"FCA\", linetype = \"Operando\")\n  ) +\n  geom_sf(\n    data = shp_ferrovias %>% filter(Name == \"Horto - Itabirito\"),\n    aes(color = \"FdA\", linetype = \"Obra abandonada\")\n  ) +\n  geom_sf(\n    data = shp_ferrovias %>% filter(Name == \"Itabirito - Rio\"),\n    aes(color = \"FdA\", linetype = \"Operando\")\n  ) +\n  scale_color_manual(\n    values = c(\"EFVM\" = \"#3cc954\", \"FCA\" = \"#60a8f6\", \"FdA\" = \"#2a4ea1\"),\n    name = \"Ferrovia\"\n  ) +\n  scale_linetype_manual(\n    values = c(\"Operando\" = \"solid\", \"Obra abandonada\" = \"dashed\"),\n    name = \"Status\"\n  ) +\n  labs(\n    title = \"Minas Gerais: algumas ferrovias\"\n  ) +\n  geom_sf_text(\n    data = shp_mg_muni %>% filter(code_muni %in% c(3106200, 3136702, 3127701, 3143302)),\n    aes(label = name_muni),\n    hjust = 1,\n    size = 2.5\n  ) +\n  xlim(-50.75, -40.25) +\n  ylim(-22.75, -14.5) +\n  theme_void() +\n  theme(\n    panel.background = element_rect(fill = \"skyblue\", color = NA)\n  )\n```\n````\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in st_point_on_surface.sfc(sf::st_zm(x)): st_point_on_surface may not\ngive correct results for longitude/latitude data\n```\n:::\n\n::: {.cell-output-display}\n![](rotina-spatial_files/figure-html/ferro-plot-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "rotina-spatial_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
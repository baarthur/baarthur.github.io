{"title":"Geolocalizando CEPs","markdown":{"yaml":{"title":"Geolocalizando CEPs","description":"A partir dos dados da RAIS","author":[{"name":"Arthur Bazolli Alvarenga","url":"https://baarthur.github.io/","affiliation":"PPGE/UFJF","affiliation-url":"https://www2.ufjf.br/poseconomia/"}],"date":"2023-09-26","date-modified":"last-modified","categories":["R","r-spatial","Geocomputação","Tutorial"],"citation":{"url":"https://baarthur.github.io/posts/2023-09-26-geoceps/"},"draft":false,"execute":{"echo":"fenced"},"format":{"html":{"include-in-header":{"text":"<style>\nh1 {\ncolor: #fff;\n}\n</style>\n"}}}},"headingText":"Introdução","containsRefs":false,"markdown":"\n\n\nPasso a passo para geolocalizar CEPs. Aqui vamos usar o pacote `{mapsapi}` do Google. Outra possibilidade é o `{cepR}` (CepAberto), mas tem um limite muito baixo de requisições por dia e, na minha experiência, é menos preciso. Tem ainda o `{osmdata}` (Open Street Map), mas o uso é um pouco mais complicado.\n\nO exemplo parte da RAIS, mas qualquer outra base pode ser usada. Cada API tem sua vantagem e desvantagem, mas a rotina geral é a mesma: preparar a base > submeter a busca (`query`) > salvar os dados > carregar.\n\n\n\n\n## Setup\n\nCarregar os pacotes necessários\n```{r}\n#| label: setup\n#| message: false\n\nlibrary(tidyverse)\nlibrary(mapsapi)\nlibrary(here)\n```\n\n\n\n\n## Preparar a base de CEPs\n\nPartindo da RAIS, vamos pegar os CEPs que queremos buscar e deixá-los no formato necessário. Como a base é muito grande, isso pode levar um tempo. \n\nSupondo que a RAIS está em um arquivo único: leia-o e salve em um objeto. Aqui usamos a função `read_fst()`, substitua por `read_csv()`,  `readRDS()` ou a função apropriada para o seu tipo de arquivo.\n\n::: {.callout-note}\nPara evitar a confusão de diretórios envolvendo `setwd()`/`getwd()` e a inversão de barras, recomendo criar um R Project. Ele já considera que todos os seus diretórios são relativos à pasta principal do projeto, assim, todos os diretórios podem ser relativos a ele. Ex.: `read_csv(\"data/rais.csv\")` em vez de `read_csv(\"C:/Documents/User/Projects/trabalho/data/rais.csv\")`.\n\nÉ bom ainda usar a função `here()` do pacote homônimo para garantir que o diretório será lido corretamente, principalmente quando se usar RMarkdown (`.Rmd`)/Quarto (`.qmd`), mas também nos scripts `.R`, como no exemplo abaixo.\n:::\n\n```{r}\n#| label: load-rais\n\ndf_estab <- fst::read_fst(here(\"data/db/df_rais_estab.fst\"))\n```\n\nAgora, vamos filtrar essa base para excluir os CEPs duplicados e remover as outras informações, não vamos precisar delas agoras. Com isso, vamos gerar uma base de CEPs. O procedimento é o seguinte:\n\n1. Primeiro, selecionamos só a variável que contém o cep (no meu caso, `cep`).\n2. Isso não é obrigatório, mas ajuda: modificamos (usando `mutate()`) a variável `cep` de duas formas,\n  + primeiro, removendo o hífen, se houver\n  + segundo, padronizando o CEP como uma variável do tipo `character` com 8 caracteres. No caso dos CEPs de SP Capital, um cuidado adicional: como eles começam com um zero à esquerda, se `cep` estivesse antes no formato de número, inserimo-lo novamente com a função `str_pad()`.\n3. Passamos a função `distinct()` para remover duplicados.\n4. Salvamos na pasta adequada e com nome legível para usar depois.\n\n::: {.callout-tip}\n1. Salve essa base na sua pasta de dados para usar novamente se precisar, principalmente se a API travar\n2. Use um formato como o `.RDS` ou o `.fst`, que ocupam menos espaço e tem leitura mais rápida. Aqui, vamos usar o `.RDS` para já salvar direto no formato de vetor, que vamos precisar lá na frente.\n:::\n\n```{r}\n#| label: filter-ceps\n\ndf_ceps <- df_estab %>% \n  select(cep) %>% \n  mutate(cep = str_remove(cep, \"-\")) %>% \n  mutate(cep = str_pad(as.character(cep), width = 8, side = \"left\", pad = 0)) %>% \n  distinct()\n\n# transformar em vetor\ndf_ceps <- df_ceps$cep %>% as.vector()\n\n# salvar\ndf_ceps %>% saveRDS(here(\"data/db/df_ceps.RDS\"))\n```\n\n\n\n\n## Configurar a API\n\nAgora, selecionamos a API desejada e fazemos a `query`. O `{mapsapi}` é minha escolha favorita para esse tipo de tarefa porque contém as informações mais precisas e é fácil de usar depois que você configura a chave.\n\nPrimeiro, crie um projeto no Google Cloud. Se você não sabe fazer isso, veja meu passo a passo no post [Acessando a Base dos Dados no R](https://baarthur.github.io/pt/posts/2023-06-20-basedosdados/).\n\nDepois disso, vá ao [console](https://console.cloud.google.com) do seu projeto, clique em **APIs e serviços**, depois em credenciais e crie uma chave API, como na imagem abaixo. \n\n![](api-create.png){height=\"200\"}\n\nVocê vai ver um alerta do google informando que sua API não está restrita: isso significa que qualquer um que tiver acesso a ela pode usá-la livremente (e cobrar no seu cartão de crédito). Eu recomendo que, no mínimo, você restrinja a API aos serviços que vai usar. Clique no nome dela para editá-la e defina as restrições, eu selecionei 16 serviços:\n\n![](api-restrict.png){height=\"400\"}\n\n::: {.callout-tip}\n**Update 2023-10-23**: Garanta que no mínimo duas APIs foram selecionadas, a `Geocoding API` e a `Geolocation API` (créditos ao [@sirtheusrey](https://twitter.com/sirtheusrey) por notar que eu esqueci de mencionar isso)\n:::\n\nAssim que tiver a sua API, copie a sua chave. Atenção: NUNCA compartilhe a sua chave com ninguém. Não faça upload de nenhum script que contenha sua chave! Assim que usá-la, recomendo apagar do script. Ou, melhor ainda, [salve no .Renviron](https://laurenilano.com/posts/api-keys/).\n\n\n\n\n## Geocodificar os CEPs\n\nVou apresentar aqui três formas de geocodificar os CEPs. Elas são quase idênticas, a diferença é que na primeira buscamos todos os CEPs direto, na segunda usamos uma função para \"tentar\" o resultado e na terceira fazemos isso aos poucos. A vantagem é reduzir o retrabalho: na primeira alternativa, se der erro, temos que voltar do começo e buscar tudo de novo. Na segunda, se der problema, temos que refazer apenas os problemáticos. A terceira é uma camada a mais de proteção: se por exemplo a sua internet cair no meio do processo, você já tem os resultados salvos para parte dos dados.\n\n\n\n### Alternativa 1: tudo de uma vez\n\nUsamos a função `mp_geocode` para geocodificação do `{mapsapi}`. Ela tem dois argumentos principais: (i) `key`, a chave API (podemos colocá-la direto na função ou salvar por fora, como abaixo) e (ii) `addresses`, que são os endereços que queremos geolocalizar. A função tem um argumento `postcode`, mas não vamos usá-lo: ele serve para limitar os endereços postais dos endereços, como nossos `addresses` já são CEPs, não faz sentido usar. O outro argumento que usamos, `timeout`, é o tempo limite (em segundos) que definimos para a API tentar buscar o CEP. Se passar esse tempo e não funcionar, ela desiste e passa para o próximo.\n\n> Nota: neste e nos chunks abaixo, estou usando `message: false` para ocultar minha chave API.\n\n```{r}\n#| label: geocode-v1\n#| message: false\n\n# chave API\nmapsapi_key <- \"sua chave API\"\n## ou, usando .Renviron:\nmapsapi_key <- Sys.getenv(\"mapsapi_key\")\n\n# query\n## obs.: aqui selecionei só os 2 primeiros para exemplo\nquery_ceps <- mp_geocode(\n  addresses = df_ceps[1:2],\n  key = mapsapi_key,\n  timeout = 11\n  )\n```\n\nDepois disso, usamos `mp_get_points()` para obter o centroide do CEP. A função faz isso a partir de todos os endereços cadastrados no Google com esse CEP ---ou seja, não reflete exatamente toda a área do CEP--- mas é uma boa aproximação. Em seguida, salvamos em um objeto na pasta adequada e podemos (de preferência, em outro script) carregar para casar com a base da RAIS.\n\n::: {.callout-tip}\nEmbora o formato `.fst` tenha a melhor compressão de todas, ele não funciona com objetos espaciais. Por isso, salvamos no formato `.RDS`, que também é muito bom.\n:::\n\n```{r}\n#| label: geocode-ceps\n\n# pegar o centroide\nshp_ceps <- mp_get_points(query_ceps)\n\n# salvar\nshp_ceps %>% saveRDS(here(\"data/shp/shp_ceps.RDS\"))\n```\n\n\n\n### Alternativa 2: safely\n\nAqui, vamos usar a função `safely()`: como explicado nesse [excelente post](https://blog.curso-r.com/posts/2017-04-09-try/) do curso-r, essa função serve para tentar rodar um código e, quando der erro, ela salva o erro em uma lista em vez de parar tudo. Passo a passo:\n\n1. Criar uma função `wrapper` (i.e., \"que embrulha\") para `mp_geocode()` e `mp_get_points()`. Essa função deve ter só um argumento: a base de dados. A chave e o timeout devem ser definidos dentro dela.\n2. Passar a base de CEPs na função que criamos, `safely()`\n  + Isso envolve usar a função `map()` para mapear os dados na função.\n  + Em seguida, transpomos os dados com `transpose()` para obter uma lista com duas sublistas: os resultados e os erros. Cada sublista tem ainda uma lista para cada resultado. É lista demais mas respire fundo, vai dar tudo certo. \n3. Selecionar só a lista de resultados e juntar tudo em um dataframe só com `bind_rows()`\n4. Salvar em um objeto na pasta adequada. Esse objeto terá duas classes: `data.frame` e `sf`, ou Simple Feature, que é a classe dos objetos espaciais.\n\n\n```{r}\n#| label: geocode-v2\n#| message: false\n\n# chave API\nmapsapi_key <- \"sua chave API\"\n## ou, usando .Renviron:\nmapsapi_key <- Sys.getenv(\"mapsapi_key\")\n\n# função envelope\ngeoceps <- function(data) {\n  mp_geocode(addresses = data, key = mapsapi_key, timeout = 11) %>% \n    mp_get_points()\n}\n\n# novamente: selecionando só 5 para exemplificar e adicionei um erro de propósito\nquery_ceps <- df_ceps[1:5] %>% map(safely(geoceps)) %>% transpose()\n\n# puxar só os resultados\nshp_ceps <- query_ceps$result %>% bind_rows()\n\n# salvar \nshp_ceps %>% saveRDS(here(\"data/shp/shp_ceps.RDS\"))\n```\n\nVisualizando os resultados:\n```{r}\n#| label: view-ceps\n\n# conferir a classe\nclass(shp_ceps)\n\n# usando kable para visualização limpa no arquivo final\nshp_ceps %>% \n  knitr::kable()\n```\n\n\n\n### Alternativa 3: por partes, safely\n\nNa alternativa 2, já evitamos um bocado de retrabalho impedindo que a função pare se encontrar um erro. Agora, vamos facilitar ainda mais a nossa vida: para evitar que um apagão, queda de internet etc apague todo o seu trabalho, vamos dividir tudo em etapas e ir salvando aos poucos. O procedimento é parecido, mas vamos usar e abusar da função `map()`:\n\n1. Partir o data frame em chunks (pedaços) menores. Eu sugiro ir de 5 mil em 5 mil; aqui no exemplo, vamos de 5 em 5 para os 17 primeiros dados. Para isso:\n  + A função `split()` vai partir os dados\n  + Dentro de split, `seq_along(data)` é uma sequência ao longo dos dados. \n  + Dividimo-la pelo tamanho máximo do chunk e depois arredondamos para cima com `ceiling()`\n  + Isso vai criar uma lista com $n$ sublistas, em que $n$ é o número de chunks. \n2. Criar uma função wrapper parecida com a do passo anterior, mas atentando para o fato de que agora temos que mapear a lista nas funções.\n  + Nota: dentro de map, usamos a sintaxe das funções anônimas, `\\(coiso) trem(coiso)`. No nosso caso, o `\\(x)` é cada chunk de ceps da lista.\n3. Agora usamos a `imap()` uma variação de `map()` que permite dar nome aos bois. \n  + Ela pede dois argumentos, que eu chamei de `x` e `y`; no caso, `y` é o identificador. Vamos usá-lo para salvar os chunks no padrão `shp_ceps_1.RDS`, `shp_ceps_2.RDS`, ..., `shp_ceps_n.RDS`.\n  + Em vez do cifrão, puxamos `result` usando a função `pluck()`. Ela permite fazer tudo de uma vez, sem quebrar o fluxo. \n\n```{r}\n#| label: geocode-v3\n#| message: false\n\n# definindo os chunks\nchunk_max <- 5\n\ndf_ceps <- df_ceps[1:17] %>% \n  split(ceiling(seq_along(df_ceps[1:17])/chunk_max))\n\n# chave API\nmapsapi_key <- Sys.getenv(\"mapsapi_key\")\n\n# função envelope\ngeoceps <- function(data) {\n  data %>% \n    map(\n      \\(x)\n      mp_geocode(addresses = x,key = mapsapi_key, timeout = 11) %>% \n        mp_get_points()\n    )\n}\n\nquery_ceps <- df_ceps %>% \n  imap(\n    \\(x, y)\n    map(x, safely(geoceps)) %>% \n      transpose() %>% \n      pluck(\"result\") %>% \n      bind_rows() %>% \n      saveRDS(here(paste0(\"data/shp/shp_ceps_\", y, \".RDS\")))\n  )\n```\n\nFinalmente, depois que você rodar a query por partes, podemos carregar os arquivos no R e montar de novo em um dataset só com nossos ceps. Para isso: \n\n1. vamos usar `list.files()` para listar todos os arquivos na pasta que seguem o padrão e mapear essa lista de padrões em `readRDS()` e, em sequência, `bind`ar as `rows`. Detalhe importante: `pattern` é uma `regex`, ou [*regular expression*](https://stringi.gagolewski.com/weave/regular_expressions.html). Nesse exemplos, estamos buscando o padrão que começa com `shp_ceps_`, seguido de um ou mais dígitos (`\\\\d_`) e do final .RDS (`\\\\.RDS$`).\n2. Agora é só `map`ear os arquivos.\n\n```{r}\n#| label: load-queries\n\npaths <- list.files(\n  path = here(\"data/shp\"),\n  pattern = \"shp_ceps_\\\\d+\\\\.RDS$\",\n  full.names = T\n)\n\nshp_ceps <- paths %>% \n  map(readRDS) %>% \n  bind_rows()\n\n# visualizando\nknitr::kable(shp_ceps)\n```\n\n\n\n\n## Bônus: background jobs\n\nQuando você estiver geolocalizando vários CEPs, isso vai demorar bastante ---talvez uma tarde inteira, talvez mais. Por isso, é útil executar como um background job: isso libera o seu R para você fazer outras coisas enquanto ele roda a API em outra seção. Só não se esqueça de verificar de vez em quando o background job para ver se tá rodando, ao menos logo que você executar. Felizmente, usando `safely()` a chance de um erro travar tudo diminui muito. O que eu gosto de fazer: executar como background job, dormir, acordar e admirar a base que baixou à noite.\n\nPara fazer um background job, temos que salvar o código dentro de um script R. Ou seja: não funciona com markdown (`.Rmd`/`.qmd`). Quando tiver seu script pronto, é só ir em **Background Jobs**, provavelmente na parte de baixo do seu RStudio, perto do console. \n\n![](bg-start.png){height=\"200\"}\n\nDepois que você iniciar o background job, é só ir acompanhando ali:\n\n![](bg-running.png){height=\"200\"}\n\nNo final, ele te avisa se deu certo. E é isso!\n","srcMarkdownNoYaml":"\n\n## Introdução\n\nPasso a passo para geolocalizar CEPs. Aqui vamos usar o pacote `{mapsapi}` do Google. Outra possibilidade é o `{cepR}` (CepAberto), mas tem um limite muito baixo de requisições por dia e, na minha experiência, é menos preciso. Tem ainda o `{osmdata}` (Open Street Map), mas o uso é um pouco mais complicado.\n\nO exemplo parte da RAIS, mas qualquer outra base pode ser usada. Cada API tem sua vantagem e desvantagem, mas a rotina geral é a mesma: preparar a base > submeter a busca (`query`) > salvar os dados > carregar.\n\n\n\n\n## Setup\n\nCarregar os pacotes necessários\n```{r}\n#| label: setup\n#| message: false\n\nlibrary(tidyverse)\nlibrary(mapsapi)\nlibrary(here)\n```\n\n\n\n\n## Preparar a base de CEPs\n\nPartindo da RAIS, vamos pegar os CEPs que queremos buscar e deixá-los no formato necessário. Como a base é muito grande, isso pode levar um tempo. \n\nSupondo que a RAIS está em um arquivo único: leia-o e salve em um objeto. Aqui usamos a função `read_fst()`, substitua por `read_csv()`,  `readRDS()` ou a função apropriada para o seu tipo de arquivo.\n\n::: {.callout-note}\nPara evitar a confusão de diretórios envolvendo `setwd()`/`getwd()` e a inversão de barras, recomendo criar um R Project. Ele já considera que todos os seus diretórios são relativos à pasta principal do projeto, assim, todos os diretórios podem ser relativos a ele. Ex.: `read_csv(\"data/rais.csv\")` em vez de `read_csv(\"C:/Documents/User/Projects/trabalho/data/rais.csv\")`.\n\nÉ bom ainda usar a função `here()` do pacote homônimo para garantir que o diretório será lido corretamente, principalmente quando se usar RMarkdown (`.Rmd`)/Quarto (`.qmd`), mas também nos scripts `.R`, como no exemplo abaixo.\n:::\n\n```{r}\n#| label: load-rais\n\ndf_estab <- fst::read_fst(here(\"data/db/df_rais_estab.fst\"))\n```\n\nAgora, vamos filtrar essa base para excluir os CEPs duplicados e remover as outras informações, não vamos precisar delas agoras. Com isso, vamos gerar uma base de CEPs. O procedimento é o seguinte:\n\n1. Primeiro, selecionamos só a variável que contém o cep (no meu caso, `cep`).\n2. Isso não é obrigatório, mas ajuda: modificamos (usando `mutate()`) a variável `cep` de duas formas,\n  + primeiro, removendo o hífen, se houver\n  + segundo, padronizando o CEP como uma variável do tipo `character` com 8 caracteres. No caso dos CEPs de SP Capital, um cuidado adicional: como eles começam com um zero à esquerda, se `cep` estivesse antes no formato de número, inserimo-lo novamente com a função `str_pad()`.\n3. Passamos a função `distinct()` para remover duplicados.\n4. Salvamos na pasta adequada e com nome legível para usar depois.\n\n::: {.callout-tip}\n1. Salve essa base na sua pasta de dados para usar novamente se precisar, principalmente se a API travar\n2. Use um formato como o `.RDS` ou o `.fst`, que ocupam menos espaço e tem leitura mais rápida. Aqui, vamos usar o `.RDS` para já salvar direto no formato de vetor, que vamos precisar lá na frente.\n:::\n\n```{r}\n#| label: filter-ceps\n\ndf_ceps <- df_estab %>% \n  select(cep) %>% \n  mutate(cep = str_remove(cep, \"-\")) %>% \n  mutate(cep = str_pad(as.character(cep), width = 8, side = \"left\", pad = 0)) %>% \n  distinct()\n\n# transformar em vetor\ndf_ceps <- df_ceps$cep %>% as.vector()\n\n# salvar\ndf_ceps %>% saveRDS(here(\"data/db/df_ceps.RDS\"))\n```\n\n\n\n\n## Configurar a API\n\nAgora, selecionamos a API desejada e fazemos a `query`. O `{mapsapi}` é minha escolha favorita para esse tipo de tarefa porque contém as informações mais precisas e é fácil de usar depois que você configura a chave.\n\nPrimeiro, crie um projeto no Google Cloud. Se você não sabe fazer isso, veja meu passo a passo no post [Acessando a Base dos Dados no R](https://baarthur.github.io/pt/posts/2023-06-20-basedosdados/).\n\nDepois disso, vá ao [console](https://console.cloud.google.com) do seu projeto, clique em **APIs e serviços**, depois em credenciais e crie uma chave API, como na imagem abaixo. \n\n![](api-create.png){height=\"200\"}\n\nVocê vai ver um alerta do google informando que sua API não está restrita: isso significa que qualquer um que tiver acesso a ela pode usá-la livremente (e cobrar no seu cartão de crédito). Eu recomendo que, no mínimo, você restrinja a API aos serviços que vai usar. Clique no nome dela para editá-la e defina as restrições, eu selecionei 16 serviços:\n\n![](api-restrict.png){height=\"400\"}\n\n::: {.callout-tip}\n**Update 2023-10-23**: Garanta que no mínimo duas APIs foram selecionadas, a `Geocoding API` e a `Geolocation API` (créditos ao [@sirtheusrey](https://twitter.com/sirtheusrey) por notar que eu esqueci de mencionar isso)\n:::\n\nAssim que tiver a sua API, copie a sua chave. Atenção: NUNCA compartilhe a sua chave com ninguém. Não faça upload de nenhum script que contenha sua chave! Assim que usá-la, recomendo apagar do script. Ou, melhor ainda, [salve no .Renviron](https://laurenilano.com/posts/api-keys/).\n\n\n\n\n## Geocodificar os CEPs\n\nVou apresentar aqui três formas de geocodificar os CEPs. Elas são quase idênticas, a diferença é que na primeira buscamos todos os CEPs direto, na segunda usamos uma função para \"tentar\" o resultado e na terceira fazemos isso aos poucos. A vantagem é reduzir o retrabalho: na primeira alternativa, se der erro, temos que voltar do começo e buscar tudo de novo. Na segunda, se der problema, temos que refazer apenas os problemáticos. A terceira é uma camada a mais de proteção: se por exemplo a sua internet cair no meio do processo, você já tem os resultados salvos para parte dos dados.\n\n\n\n### Alternativa 1: tudo de uma vez\n\nUsamos a função `mp_geocode` para geocodificação do `{mapsapi}`. Ela tem dois argumentos principais: (i) `key`, a chave API (podemos colocá-la direto na função ou salvar por fora, como abaixo) e (ii) `addresses`, que são os endereços que queremos geolocalizar. A função tem um argumento `postcode`, mas não vamos usá-lo: ele serve para limitar os endereços postais dos endereços, como nossos `addresses` já são CEPs, não faz sentido usar. O outro argumento que usamos, `timeout`, é o tempo limite (em segundos) que definimos para a API tentar buscar o CEP. Se passar esse tempo e não funcionar, ela desiste e passa para o próximo.\n\n> Nota: neste e nos chunks abaixo, estou usando `message: false` para ocultar minha chave API.\n\n```{r}\n#| label: geocode-v1\n#| message: false\n\n# chave API\nmapsapi_key <- \"sua chave API\"\n## ou, usando .Renviron:\nmapsapi_key <- Sys.getenv(\"mapsapi_key\")\n\n# query\n## obs.: aqui selecionei só os 2 primeiros para exemplo\nquery_ceps <- mp_geocode(\n  addresses = df_ceps[1:2],\n  key = mapsapi_key,\n  timeout = 11\n  )\n```\n\nDepois disso, usamos `mp_get_points()` para obter o centroide do CEP. A função faz isso a partir de todos os endereços cadastrados no Google com esse CEP ---ou seja, não reflete exatamente toda a área do CEP--- mas é uma boa aproximação. Em seguida, salvamos em um objeto na pasta adequada e podemos (de preferência, em outro script) carregar para casar com a base da RAIS.\n\n::: {.callout-tip}\nEmbora o formato `.fst` tenha a melhor compressão de todas, ele não funciona com objetos espaciais. Por isso, salvamos no formato `.RDS`, que também é muito bom.\n:::\n\n```{r}\n#| label: geocode-ceps\n\n# pegar o centroide\nshp_ceps <- mp_get_points(query_ceps)\n\n# salvar\nshp_ceps %>% saveRDS(here(\"data/shp/shp_ceps.RDS\"))\n```\n\n\n\n### Alternativa 2: safely\n\nAqui, vamos usar a função `safely()`: como explicado nesse [excelente post](https://blog.curso-r.com/posts/2017-04-09-try/) do curso-r, essa função serve para tentar rodar um código e, quando der erro, ela salva o erro em uma lista em vez de parar tudo. Passo a passo:\n\n1. Criar uma função `wrapper` (i.e., \"que embrulha\") para `mp_geocode()` e `mp_get_points()`. Essa função deve ter só um argumento: a base de dados. A chave e o timeout devem ser definidos dentro dela.\n2. Passar a base de CEPs na função que criamos, `safely()`\n  + Isso envolve usar a função `map()` para mapear os dados na função.\n  + Em seguida, transpomos os dados com `transpose()` para obter uma lista com duas sublistas: os resultados e os erros. Cada sublista tem ainda uma lista para cada resultado. É lista demais mas respire fundo, vai dar tudo certo. \n3. Selecionar só a lista de resultados e juntar tudo em um dataframe só com `bind_rows()`\n4. Salvar em um objeto na pasta adequada. Esse objeto terá duas classes: `data.frame` e `sf`, ou Simple Feature, que é a classe dos objetos espaciais.\n\n\n```{r}\n#| label: geocode-v2\n#| message: false\n\n# chave API\nmapsapi_key <- \"sua chave API\"\n## ou, usando .Renviron:\nmapsapi_key <- Sys.getenv(\"mapsapi_key\")\n\n# função envelope\ngeoceps <- function(data) {\n  mp_geocode(addresses = data, key = mapsapi_key, timeout = 11) %>% \n    mp_get_points()\n}\n\n# novamente: selecionando só 5 para exemplificar e adicionei um erro de propósito\nquery_ceps <- df_ceps[1:5] %>% map(safely(geoceps)) %>% transpose()\n\n# puxar só os resultados\nshp_ceps <- query_ceps$result %>% bind_rows()\n\n# salvar \nshp_ceps %>% saveRDS(here(\"data/shp/shp_ceps.RDS\"))\n```\n\nVisualizando os resultados:\n```{r}\n#| label: view-ceps\n\n# conferir a classe\nclass(shp_ceps)\n\n# usando kable para visualização limpa no arquivo final\nshp_ceps %>% \n  knitr::kable()\n```\n\n\n\n### Alternativa 3: por partes, safely\n\nNa alternativa 2, já evitamos um bocado de retrabalho impedindo que a função pare se encontrar um erro. Agora, vamos facilitar ainda mais a nossa vida: para evitar que um apagão, queda de internet etc apague todo o seu trabalho, vamos dividir tudo em etapas e ir salvando aos poucos. O procedimento é parecido, mas vamos usar e abusar da função `map()`:\n\n1. Partir o data frame em chunks (pedaços) menores. Eu sugiro ir de 5 mil em 5 mil; aqui no exemplo, vamos de 5 em 5 para os 17 primeiros dados. Para isso:\n  + A função `split()` vai partir os dados\n  + Dentro de split, `seq_along(data)` é uma sequência ao longo dos dados. \n  + Dividimo-la pelo tamanho máximo do chunk e depois arredondamos para cima com `ceiling()`\n  + Isso vai criar uma lista com $n$ sublistas, em que $n$ é o número de chunks. \n2. Criar uma função wrapper parecida com a do passo anterior, mas atentando para o fato de que agora temos que mapear a lista nas funções.\n  + Nota: dentro de map, usamos a sintaxe das funções anônimas, `\\(coiso) trem(coiso)`. No nosso caso, o `\\(x)` é cada chunk de ceps da lista.\n3. Agora usamos a `imap()` uma variação de `map()` que permite dar nome aos bois. \n  + Ela pede dois argumentos, que eu chamei de `x` e `y`; no caso, `y` é o identificador. Vamos usá-lo para salvar os chunks no padrão `shp_ceps_1.RDS`, `shp_ceps_2.RDS`, ..., `shp_ceps_n.RDS`.\n  + Em vez do cifrão, puxamos `result` usando a função `pluck()`. Ela permite fazer tudo de uma vez, sem quebrar o fluxo. \n\n```{r}\n#| label: geocode-v3\n#| message: false\n\n# definindo os chunks\nchunk_max <- 5\n\ndf_ceps <- df_ceps[1:17] %>% \n  split(ceiling(seq_along(df_ceps[1:17])/chunk_max))\n\n# chave API\nmapsapi_key <- Sys.getenv(\"mapsapi_key\")\n\n# função envelope\ngeoceps <- function(data) {\n  data %>% \n    map(\n      \\(x)\n      mp_geocode(addresses = x,key = mapsapi_key, timeout = 11) %>% \n        mp_get_points()\n    )\n}\n\nquery_ceps <- df_ceps %>% \n  imap(\n    \\(x, y)\n    map(x, safely(geoceps)) %>% \n      transpose() %>% \n      pluck(\"result\") %>% \n      bind_rows() %>% \n      saveRDS(here(paste0(\"data/shp/shp_ceps_\", y, \".RDS\")))\n  )\n```\n\nFinalmente, depois que você rodar a query por partes, podemos carregar os arquivos no R e montar de novo em um dataset só com nossos ceps. Para isso: \n\n1. vamos usar `list.files()` para listar todos os arquivos na pasta que seguem o padrão e mapear essa lista de padrões em `readRDS()` e, em sequência, `bind`ar as `rows`. Detalhe importante: `pattern` é uma `regex`, ou [*regular expression*](https://stringi.gagolewski.com/weave/regular_expressions.html). Nesse exemplos, estamos buscando o padrão que começa com `shp_ceps_`, seguido de um ou mais dígitos (`\\\\d_`) e do final .RDS (`\\\\.RDS$`).\n2. Agora é só `map`ear os arquivos.\n\n```{r}\n#| label: load-queries\n\npaths <- list.files(\n  path = here(\"data/shp\"),\n  pattern = \"shp_ceps_\\\\d+\\\\.RDS$\",\n  full.names = T\n)\n\nshp_ceps <- paths %>% \n  map(readRDS) %>% \n  bind_rows()\n\n# visualizando\nknitr::kable(shp_ceps)\n```\n\n\n\n\n## Bônus: background jobs\n\nQuando você estiver geolocalizando vários CEPs, isso vai demorar bastante ---talvez uma tarde inteira, talvez mais. Por isso, é útil executar como um background job: isso libera o seu R para você fazer outras coisas enquanto ele roda a API em outra seção. Só não se esqueça de verificar de vez em quando o background job para ver se tá rodando, ao menos logo que você executar. Felizmente, usando `safely()` a chance de um erro travar tudo diminui muito. O que eu gosto de fazer: executar como background job, dormir, acordar e admirar a base que baixou à noite.\n\nPara fazer um background job, temos que salvar o código dentro de um script R. Ou seja: não funciona com markdown (`.Rmd`/`.qmd`). Quando tiver seu script pronto, é só ir em **Background Jobs**, provavelmente na parte de baixo do seu RStudio, perto do console. \n\n![](bg-start.png){height=\"200\"}\n\nDepois que você iniciar o background job, é só ir acompanhando ali:\n\n![](bg-running.png){height=\"200\"}\n\nNo final, ele te avisa se deu certo. E é isso!\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":"fenced","output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"include-in-header":{"text":"<style>\nh1 {\ncolor: #fff;\n}\n</style>\n"},"output-file":"index.html"},"language":{"toc-title-document":"Índice","toc-title-website":"Nesta página","related-formats-title":"Outros formatos","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Fonte","section-title-abstract":"Resumo","section-title-appendices":"Apêndices","section-title-footnotes":"Notas de rodapé","section-title-references":"Referências","section-title-reuse":"Reuso","section-title-copyright":"Direito autoral","section-title-citation":"Citação","appendix-attribution-cite-as":"Por favor, cite este trabalho como:","appendix-attribution-bibtex":"BibTeX","title-block-author-single":"Autor","title-block-author-plural":"Autores","title-block-affiliation-single":"Afiliação","title-block-affiliation-plural":"Afiliações","title-block-published":"Data de Publicação","title-block-modified":"Data de Modificação","callout-tip-title":"Dica","callout-note-title":"Nota","callout-warning-title":"Aviso","callout-important-title":"Importante","callout-caution-title":"Cuidado","code-summary":"Código","code-tools-menu-caption":"Código","code-tools-show-all-code":"Mostrar o código","code-tools-hide-all-code":"Esconder o código","code-tools-view-source":"Ver o código fonte","code-tools-source-code":"Código fonte","code-line":"Linha","code-lines":"Linhas","copy-button-tooltip":"Copiar para a área de transferência","copy-button-tooltip-success":"Copiada","repo-action-links-edit":"Editar essa página","repo-action-links-source":"Ver o código fonte","repo-action-links-issue":"Criar uma issue","back-to-top":"De volta ao topo","search-no-results-text":"Nenhum resultado","search-matching-documents-text":"documentos correspondentes","search-copy-link-title":"Copiar link para a busca","search-hide-matches-text":"Esconder correspondências adicionais","search-more-match-text":"mais correspondência neste documento","search-more-matches-text":"mais correspondências neste documento","search-clear-button-title":"Limpar","search-detached-cancel-button-title":"Cancelar","search-submit-button-title":"Enviar","search":"Procurar","toggle-section":"Alternar seção","toggle-sidebar":"Alternar barra lateral","toggle-dark-mode":"Alternar modo escuro","toggle-reader-mode":"Alternar modo de leitor","toggle-navigation":"Alternar de navegação","crossref-fig-title":"Figura","crossref-tbl-title":"Tabela","crossref-lst-title":"Listagem","crossref-thm-title":"Teorema","crossref-lem-title":"Lema","crossref-cor-title":"Corolário","crossref-prp-title":"Proposição","crossref-cnj-title":"Conjectura","crossref-def-title":"Definição","crossref-exm-title":"Exemplo","crossref-exr-title":"Exercício","crossref-ch-prefix":"Capítulo","crossref-apx-prefix":"Apêndice","crossref-sec-prefix":"Seção","crossref-eq-prefix":"Equação","crossref-lof-title":"Lista de Figuras","crossref-lot-title":"Lista de Tabelas","crossref-lol-title":"Lista de Listagens","environment-proof-title":"Comprovação","environment-remark-title":"Comentário","environment-solution-title":"Solução","listing-page-order-by":"Ordenar por","listing-page-order-by-default":"Pré-selecionado","listing-page-order-by-date-asc":"Mais velho","listing-page-order-by-date-desc":"O mais novo","listing-page-order-by-number-desc":"Decrescente","listing-page-order-by-number-asc":"Crescente","listing-page-field-date":"Data","listing-page-field-title":"Título","listing-page-field-description":"Descrição","listing-page-field-author":"Autor","listing-page-field-filename":"Nome do arquivo","listing-page-field-filemodified":"Arquivo modificado","listing-page-field-subtitle":"Subtítulo","listing-page-field-readingtime":"Tempo de leitura","listing-page-field-categories":"Categorias","listing-page-minutes-compact":"{0} minutos","listing-page-category-all":"Tudo","listing-page-no-matches":"Nenhum item correspondente"},"metadata":{"lang":"pt-BR","fig-responsive":true,"quarto-version":"1.4.60","theme":{"light":["flatly","../../styles.scss"],"dark":["darkly","../../styles.scss"]},"mainfont":"Atkinson Hyperlegible","title-block-banner":true,"title":"Geolocalizando CEPs","description":"A partir dos dados da RAIS","author":[{"name":"Arthur Bazolli Alvarenga","url":"https://baarthur.github.io/","affiliation":"PPGE/UFJF","affiliation-url":"https://www2.ufjf.br/poseconomia/"}],"date":"2023-09-26","date-modified":"last-modified","categories":["R","r-spatial","Geocomputação","Tutorial"],"citation":{"url":"https://baarthur.github.io/posts/2023-09-26-geoceps/"},"draft":false},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
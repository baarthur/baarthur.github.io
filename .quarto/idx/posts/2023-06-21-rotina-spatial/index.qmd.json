{"title":"Rotina espacial no R","markdown":{"yaml":{"title":"Rotina espacial no R","description":"Aprenda a baixar, filtrar e combinar dados","author":[{"name":"Arthur Bazolli Alvarenga","url":"https://baarthur.github.io/","affiliation":"PPGE/UFJF","affiliation-url":"https://www2.ufjf.br/poseconomia/"}],"date":"2023-06-21","categories":["R","r-spatial","Geocomputação","Tutorial"],"citation":{"url":"https://baarthur.github.io/posts/2023-06-20-rotina-spatial/"},"image":"thumbnail.png","draft":false,"execute":{"echo":"fenced"},"format":{"html":{"include-in-header":{"text":"<style>\nh1 {\ncolor: #fff;\n}\n</style>\n"}}}},"headingText":"Introdução","containsRefs":false,"markdown":"\n\n\nMuitos amigos me perguntam como fazer operações espaciais no `R`. Então, decidi criar essa rotina muito simples, com o mínimo para começar e algumas operações básicas.\n\nComo eu já disse no [post sobre a Base dos Dados](https://baarthur.github.io/posts/2023-06-20-basedosdados/): crie um R Project e seja organizado, ajude o você de amanhã! Ele vai agradecer.\n\n### Links úteis\n\n* A melhor referência que eu conheço para dados espaciais no R: O livro [Geocomputation With R](https://r.geocompx.org/).\n* Livro em português lançado recentemente. Ainda não tive oportunidade de ler, mas parece muito bom!\n  + [Cartografia Temática em R para estudantes de Geografia](https://ligiaviz.github.io/RCartoTematica/)\n* Excelentes tutoriais também no [r-spatial.org](https://r-spatial.org/)\n* [geobr](https://ipeagit.github.io/geobr/): mapas brasileiros em alta qualidade no R!\n* [aopdata](https://ipeagit.github.io/aopdata/): Projeto Acesso a Oportunidades do Ipea, com base muito rica para download direto no R.\n* [Geosampa](https://geosampa.prefeitura.sp.gov.br/PaginasPublicas/_SBC.aspx): portal da Prefeitura de São Paulo com diversos dados geolocalizados\n* [BHMap](https://bhmap.pbh.gov.br/v2/mapa/idebhgeo) e [IDE Sistema](https://idesisema.meioambiente.mg.gov.br/webgis): idem, para BH e o Governo de Minas\n* [Mapbiomas](https://mapbiomas.org/): nunca usei, mas é referência para o pessoal que trabalha com meio ambiente.\n* Shapefiles de ferrovias, rodovias, aeroportos, portos e mais no site do [ONTL/EPL](https://ontl2.epl.gov.br/downloads)\n\n\n\n## Setup\n\nDefina um bloco de código (`Ctrl` + `Alt` + `I`) para chamar os pacotes necessários. Use a opção `#| label: setup`, como abaixo, para ele sempre ser executado no começo.\n```{r}\n#| label: setup\n#| results: hold\n\n# geral e tratamento de dados\nlibrary(here)\nlibrary(janitor)\nlibrary(tidyverse)\n\n# operações espaciais\nlibrary(sf)\n\n# bases de dados\nlibrary(geobr)\nlibrary(sidrar)\n```\n\n\n\n## Carregando dados\n\n### Da internet\n\nVários shapefiles brasileiros estão disponíveis online. Alguns podem ser baixados direto no `R`, como o `{geobr}` e o `{aopdata}`. Nesse exemplo, vamos baixar o shapefile dos municípios mineiros usando o `{geobr}`:\n```{r}\n#| label: download-shp\n\nshp_mg_muni <- read_municipality(\n  code_muni = \"MG\",\n  showProgress = FALSE\n)\n```\n\nSegundo o manual da função `read_municipality()` (digite `?read_municipality` no console ou vá em `Help` e digite o nome da função), podemos baixar só os municípios de um estado especificando o código do estado ou sua sigla em `code_muni`, ou ainda baixar apenas uma cidade especificando o seu código de 7 dígitos do IBGE.\n\nAdicionei, ainda, `showProgress = FALSE` para não mostrar o status do download enquanto baixa. Outra opção é `simplified = FALSE` para baixar o shapefile mais detalhado possível. Isso é muito mais pesado; na dúvida, não baixe.\n\n:::{.callout-info}\nÀs vezes, um shapefile \"dá pau\" na hora de fazer as operações que vamos ver lá na frente. Se isso acontecer, use a transformação `st_make_valid()` para consertá-lo:\n:::\n\n```{r}\n#| label: make-valid\n\nshp_mg_muni <- shp_mg_muni %>% \n  st_make_valid()\n```\n\n\n### Do computador\n\nNeste exemplo, vamos carregar dois shapefiles para fazer operações espaciais: a malha de municípios mineiros, no formato `.shp`, e um mapa ferroviário, no formato do Google Earth (`.kml`). Usando o pacote `{sf}`, carregamos os shapefiles com `st_read()`. Supondo que você tem uma pasta chamada `shp` dentro da pasta `data` com seus shapefiles:\n\n```{r}\n#| label: read-mg\n#| eval: false\n\nshp_mg_muni <- here(\"data/shp/shapefile_minas.shp\") %>% \n  st_read()\n```\n\n::: {.callout-warning}\nOs shapefiles do tipo `.shp` tem pelo menos quatro camadas, em arquivos separados: `.dbf`, `.prj`, `.shp` e `.shx`. Por mais que na função `st_read()` nós passemos só o `.shp`, ela está usando todas as camadas; logo, elas devem estar na pasta também! \n:::\n\n```{r}\n#| label: read-ferro-background\n#| echo: false\n\nshp_ferrovias <- here(\"posts/2023-06-21-rotina-spatial/data/shp/ferrovias.kml\") %>% \n  st_read()\n```\n\n```{r}\n#| label: read-ferro\n#| eval: false\n\nshp_ferrovias <- here(\"data/shp/ferrovias.kml\") %>% \n  st_read()\n```\n\n::: {.fallout-info}\nNo Quarto (`.qmd`) e no RMarkdown (`.Rmd`), usamos a função `here()` do pacote homônimo para passar endereços relativos. Isso evita a bagunça que acontece com a dupla `setwd()`/`getwd()` e a chatice de ficar invertendo barras nos caminhos absolutos. Os endereços relativos são *relativos* à pasta origem do seu projeto, porque o R Project entende qur você está partindo dali.\n:::\n\n\n### Compatibilidade de coordenadas\n\nExistem diferentes padrões de coordenadas (**CRS**, de *Coordinate Reference System*): o mais comum é o WGS 84, usado nos GPS e no Google Maps. Mas, como a terra não é plana, alguns padrões são mais adequados para locais diferentes. No Brasil, mapas administrativos costumam usar o Sirgas 2000 e suas variantes. Por isso, temos ficar atentos se nossos shapefiles estão no mesmo padrão! Para verificar:\n\n```{r}\n#| label: check-crs\n\nst_crs(shp_mg_muni)\nst_crs(shp_ferrovias)\n```\n\nNesse exemplo, a malha municipal usa o Sirgas 2000, enquanto o mapa de ferrovias usa o WGS 84. Como eu prefiro o primeiro CRS, vou transformar o seguno para que também fique em Sirgas 2000. \n\n::: {.callout-tip}\nCada CRS tem um código **EPSG** associado. No caso do Sirgas 2000 é o 4674, e para o WGS 84, é o 4326. Veja mais em [epsg.io](https://epsg.io/).\n:::\n\n```{r}\n#| label: set-crs\n\n# Alternativa 1: modificar manualmente inserindo o CRS desejado.\nshp_ferrovias <- shp_ferrovias %>% \n  st_transform(crs = 4674)\n\n# Alternativa 2: modificar o CRS de X para que seja igual ao de Y.\nshp_ferrovias <- shp_ferrovias %>% \n  st_transform(crs = st_crs(shp_mg_muni))\n```\n\n\n\n## Filtrar shapefiles\n\nSuponha que queremos filtrar as cidades que são atravessadas por algumas ferrovias. Podemos fazer isso com o `st_filter()`. Mas antes, um resumo sobre as operações espaciais:\n\nO pacte `{sf}` contém uma série de funções que computam relações topológicas entre objetos espaciais (da classe `simple.feature`). Por exemplo: `st_intersects(x,y)` indica se `x` cruza `y`; `st_covers(x,y)`, se `x` cobre `y` e o contrário por `st_covered_by(x,y)` e assim em diante. Leia mais sobre essas operações no excelente [livro do Robin Lovelace](https://r.geocompx.org/geometry-operations.html) e no site do [PostGIS](http://postgis.net/workshops/postgis-intro/spatial_relationships.html), pois as operações realizadas em SQL são basicamente as mesmsas que o `{sf}` faz no `R`.\n\nEssas operações espaciais também podem ser usadas como predicado para filtrar ou juntar dados. Nesse exemplo, vamos usar o predicado `st_intersects`:\n```{r}\nshp_muni_ferro <- shp_mg_muni %>% \n  st_filter(shp_ferrovias, .predicate = st_intersects)\n```\n\nO novo objeto contém 190 municípios: apenas aqueles atravessados pelas ferrovias contidas no `.kml`. Alternativamente, podemos só salvar o novo objeto em cima do antigo: `shp_mg_muni <- shp_mg_muni %>% (...)`\n\n\n\n## Combinar bases\n\nOutra operação poderosa no R é combinar informações de uma base com um shapefile. Nesse exemplo, vamos usar uma base de população municipal do IBGE para cruzar com o shapefile de cidades mineiras. \n\n\n### Baixando dados do IBGE com o SidraR\n\nO Sidra ---Sistema IBGE de Recuperação Automática--- pode ser acessado diretamente pelo R. Você pode tanto buscar termos específicos, usando `search_sidra(\"termo\")`, quanto baixar diretamente uma tabela que você já conheça. Vamos usar o exemplo completo: vou buscar informações sobre população.\n\n```{r}\n#| label: search_sidra\n#| eval: false\n\nsearch_sidra(\"população\")\n```\n\nO resultado retornou mais de 90 tabelas. Como isso é muito confuso, prefiro ir no site do Sidra, ver a tabela que eu quero e baixar no R. No caso, quero a tabela `6579`. Vamos ver as opções disponíveis para ela:\n\n```{r}\n#| label: info_sidra\n\ninfo_sidra(6579)\n```\n\nDe posse dessas informações, podemos configurar a chamada da função `get_sidra()`:\n\n```{r}\n#| label: get_sidra\n\ndf_pop <- get_sidra(\n  6579,\n  period = \"2021\",\n  geo = \"City\"\n)\n\nglimpse(df_pop)\n```\n\nE assim, baixamos a população de 2021 para todos os municípios brasileiros. No entanto, essa tabela do IBGE não está organizada da melhor forma pra processamento no R. Podemos melhorar removendo as informações desnecessárias (`select()`) e limpando os nomes (`clean_names()` e `rename()`) para compatibilizar com a outra tabela.\n\n::: {.callout-tip}\nUse os mesmos nomes para variáveis comuns nos dois objetos. Não é obrigatório, mas facilita sua vida; caso contrário, tem que especificar qual variável de `x` é igual a qual variável de `y` para dar o join. Como o shapefile do `{geobr}` vem com nomes padronizados, vamos adotá-la e modificar a base do IBGE.  \n:::\n\n```{r}\n#| label: tidy-data\n\n# passo 1: limpar nomes (tirar maiúsculas, espaços e outras complicações)\ndf_pop <- df_pop %>% \n  clean_names() \n\n# passo 2: remover o que não precismos e renomear. Fazemos isso tudo junto com transmute, na sintaxe novo_nome = nome_antigo\ndf_pop <- df_pop %>% \n  transmute(\n    pop = valor, code_muni = as.numeric(municipio_codigo),\n    year = as.numeric(ano)\n  )\n```\n\nAo usarmos transmute, estamos ao mesmo tempo renomeando as variáveis que querendo e removendo as que não estão ali. Note que também passei `as.numeric()` em `code_muni` e `ano`, pois estavam como `character.` No caso de `code_muni`, essa informação é numérica (`numeric`) na base do `{geobr}`, então ia dar erro no join; já no caso do ano, é porque facilita quando esse tipo de informação é numérica (por exemplo, para filtrar datas maiores do que `x`).\n\n::: {.callout-warning}\nA informação de nome do município **frequentemente** está diferente entre bases. Ex.: acentuação, hifens, etc. Para não dar erro, prefira **SEMPRE** usar o código em vez do nome; repare que até removi o nome da cidade e vou usar apenas o do `{geobr}`. Nesse caso, a base do IBGE tem a sigla do estado junto do nome do município, como \"Abadia dos Dourados - MG\".\n:::\n\n\n### Juntando: população e shapefile\n\nAgora é partir para o abraço. Vamos jogar as informações do IBGE no shapefile ---ou vice-versa; nesse caso (não é sempre), a ordem não importa.\n\n```{r}\n#| label: join\n\nshp_mg_muni <- shp_mg_muni %>% \n  left_join(df_pop)\n```\n\n\n\n## Visualização\n\n### Mapa de municípios e população\n\nVamos plotar o mapa de Minas Gerais, colorindo de acordo com a população.\n\n```{r}\n#| label: basic-plot\n\nggplot() +\n  geom_sf(\n    data = shp_mg_muni,\n    aes(fill = pop)\n  )\n```\n\nPodemos customizar esse mapa adiconando camadas e capadas. As duas mais importantes: uma camada para a escala de cores do `fill` (preenchimento) e outra para o tema.\n\nExistem duas coleções de paletas muito famosas: Brewer e Viridis. A primeira tem cores mais \"comuns\", mas a segunda dá um contraste muito bom. Abaixo, as paletas de cada coleção e a sintaxe (substitua `XXX` pelo tipo de `aesthetic` em uso: `fill`, `color` etc.)\n\n* Brewer: https://r-graph-gallery.com/38-rcolorbrewers-palettes.html\n  + Discreta: `ggplot() + (...) + scale_XXX_brewer()`\n  + Condtínua: `ggplot() + (...) + scale_XXX_distiller()`\n  + Binned: `ggplot() + (...) + scale_XXX_fermenter()`\n* Viridis: https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html\n  + Discreta: `ggplot() + (...) + scale_XXX_viridis_d()`\n  + Condtínua: `ggplot() + (...) + scale_XXX_viridis_c()`\n  + Binned: `ggplot() + (...) + scale_XXX_viridis_b()`\n\nExemplo com viridis\n```{r}\n#| label: cool-plot-viridis\n\nggplot() +\n  geom_sf(\n    data = shp_mg_muni,\n    aes(fill = pop),\n    color = \"lightgrey\"\n  ) +\n  scale_fill_viridis_c(\n    option = \"magma\",\n    direction = -1,\n    name = \"População\", \n    labels = scales::comma_format(big.mark = \" \", decimal.mark = \",\")\n  ) +\n  labs(\n    title = \"População dos municípios mineiros em 2021\",\n    caption = \"Fonte: IBGE (2023)\"\n  ) +\n  theme_void()\n```\n\nExemplo com Brewer:\n```{r}\n#| label: cool-plot-brewer\n\nggplot() +\n  geom_sf(\n    data = shp_mg_muni,\n    aes(fill = pop),\n    color = \"lightgrey\"\n  ) +\n  scale_fill_distiller(\n    palette = \"YlGnBu\",\n    direction = 1,\n    name = \"População\", \n    labels = scales::comma_format(big.mark = \" \", decimal.mark = \",\")\n  ) +\n  labs(\n    title = \"População dos municípios mineiros em 2021\",\n    caption = \"Fonte: IBGE (2023)\"\n  ) +\n  theme_void()\n```\n\n#### Melhorando o mapa\n\nDe cara, eu acho que podemos melhorar esse mapa de duas formas: \n\n1. A escala não é muito útil. Temos só uma cidade com mais de 1 milhão de habitantes e só 4 com mais de 500 mil, então uma escala `binned` pode ser mais útil do que uma contínua. \n2. A às vezes os limites municipais mais poluem do que ajudam. Nesse caso, eu gosto de definir `color = NA` ou deixar `color` na mesma escala do `fill`. \n  + Vai depender do tamanho da sua malha e da precisão dos shapefiles: se ficar um vazio esquisito entre um polígono e outro, unifique color e fill.\n\nPrimeiro, vamos definir os argumentos de `scale_...` do lado de fora, para aplicar no `fill` e no `color` de forma unificada e diminuir o risco de erro humano. Nesse processo, vamos definir os `breaks` meio no olho, mas se quiser você pode usar quantis. Escolhi os valores abaixo vendo o que ficava melhor no mapa, tentando criar um equilíbrio de forma que permita distinguir as disparidades regionais, mas sem prejudicar muito o conforto visual. Para usar quantis, é só usar em `breaks` a função `quantile(x, probs = seq(0,1, p))` em que `x` é a variável sendo quantificada (no caso, `pop`) e definimos o vetor de probabilidades como sendo a sequência de 0 a 1 de p em p. Por exemplo: para quartis, p = 0,25; para decis, p = 0,10 e assim por diante.\n\n```{r}\n#| label: scale-args\n\nscale_args <- list(\n  palette = \"YlGnBu\",\n    direction = 1,\n    name = \"População\", \n    labels = scales::comma_format(big.mark = \" \", decimal.mark = \",\"),\n    breaks = c(5000, 25000, 50000, 100000, 250000, 500000, 2500000)\n)\n```\n\nAgora, precisamos de um pouco de atenção: salvamos os argumentos numa lista e para usá-los na escala, usamos a função `do.call(f,x)`, que faz uma chamada `call` à função `f()` usando os argumentos de `x`:\n```{r}\n#| label: coolest-plot-brewer\n\nggplot() +\n  geom_sf(\n    data = shp_mg_muni,\n    aes(fill = pop, color = pop)) +\n  do.call(scale_fill_fermenter, scale_args) +\n  do.call(scale_color_fermenter, scale_args) +\n  labs(\n    title = \"População dos municípios mineiros em 2021\",\n    caption = \"Fonte: IBGE (2023)\"\n  ) +\n  theme_void()\n```\n\n### Mapa de municípios e ferrovias\n\n```{r}\n#| label: ferro-plot\n\nshp_br <- read_state(showProgress = F)\n\nggplot() +\n  geom_sf(\n    data = shp_br %>% filter(abbrev_state != \"MG\"),\n    fill = \"grey85\",\n    color = \"grey60\"\n  ) +\n  geom_sf(\n    data = shp_mg_muni,\n    fill = \"grey95\",\n    color = \"grey90\"\n  ) + \n  geom_sf(\n    data = shp_ferrovias %>% filter(Name %in% c(\"BH - Nova Era\", \"Nova Era - Pedro Nolasco\")),\n    aes(color = \"EFVM\", linetype = \"Operando\")\n  ) +\n  geom_sf(\n    data = shp_ferrovias %>% filter(Name %in% c(\"Horto - Salvador\", \"Corinto - Pirapora\")),\n    aes(color = \"FCA\", linetype = \"Operando\")\n  ) +\n  geom_sf(\n    data = shp_ferrovias %>% filter(Name == \"Horto - Itabirito\"),\n    aes(color = \"FdA\", linetype = \"Obra abandonada\")\n  ) +\n  geom_sf(\n    data = shp_ferrovias %>% filter(Name == \"Itabirito - Rio\"),\n    aes(color = \"FdA\", linetype = \"Operando\")\n  ) +\n  scale_color_manual(\n    values = c(\"EFVM\" = \"#3cc954\", \"FCA\" = \"#60a8f6\", \"FdA\" = \"#2a4ea1\"),\n    name = \"Ferrovia\"\n  ) +\n  scale_linetype_manual(\n    values = c(\"Operando\" = \"solid\", \"Obra abandonada\" = \"dashed\"),\n    name = \"Status\"\n  ) +\n  labs(\n    title = \"Minas Gerais: algumas ferrovias\"\n  ) +\n  geom_sf_text(\n    data = shp_mg_muni %>% filter(code_muni %in% c(3106200, 3136702, 3127701, 3143302)),\n    aes(label = name_muni),\n    hjust = 1,\n    size = 2.5\n  ) +\n  xlim(-50.75, -40.25) +\n  ylim(-22.75, -14.5) +\n  theme_void() +\n  theme(\n    panel.background = element_rect(fill = \"skyblue\", color = NA)\n  )\n```\n\n","srcMarkdownNoYaml":"\n\n## Introdução\n\nMuitos amigos me perguntam como fazer operações espaciais no `R`. Então, decidi criar essa rotina muito simples, com o mínimo para começar e algumas operações básicas.\n\nComo eu já disse no [post sobre a Base dos Dados](https://baarthur.github.io/posts/2023-06-20-basedosdados/): crie um R Project e seja organizado, ajude o você de amanhã! Ele vai agradecer.\n\n### Links úteis\n\n* A melhor referência que eu conheço para dados espaciais no R: O livro [Geocomputation With R](https://r.geocompx.org/).\n* Livro em português lançado recentemente. Ainda não tive oportunidade de ler, mas parece muito bom!\n  + [Cartografia Temática em R para estudantes de Geografia](https://ligiaviz.github.io/RCartoTematica/)\n* Excelentes tutoriais também no [r-spatial.org](https://r-spatial.org/)\n* [geobr](https://ipeagit.github.io/geobr/): mapas brasileiros em alta qualidade no R!\n* [aopdata](https://ipeagit.github.io/aopdata/): Projeto Acesso a Oportunidades do Ipea, com base muito rica para download direto no R.\n* [Geosampa](https://geosampa.prefeitura.sp.gov.br/PaginasPublicas/_SBC.aspx): portal da Prefeitura de São Paulo com diversos dados geolocalizados\n* [BHMap](https://bhmap.pbh.gov.br/v2/mapa/idebhgeo) e [IDE Sistema](https://idesisema.meioambiente.mg.gov.br/webgis): idem, para BH e o Governo de Minas\n* [Mapbiomas](https://mapbiomas.org/): nunca usei, mas é referência para o pessoal que trabalha com meio ambiente.\n* Shapefiles de ferrovias, rodovias, aeroportos, portos e mais no site do [ONTL/EPL](https://ontl2.epl.gov.br/downloads)\n\n\n\n## Setup\n\nDefina um bloco de código (`Ctrl` + `Alt` + `I`) para chamar os pacotes necessários. Use a opção `#| label: setup`, como abaixo, para ele sempre ser executado no começo.\n```{r}\n#| label: setup\n#| results: hold\n\n# geral e tratamento de dados\nlibrary(here)\nlibrary(janitor)\nlibrary(tidyverse)\n\n# operações espaciais\nlibrary(sf)\n\n# bases de dados\nlibrary(geobr)\nlibrary(sidrar)\n```\n\n\n\n## Carregando dados\n\n### Da internet\n\nVários shapefiles brasileiros estão disponíveis online. Alguns podem ser baixados direto no `R`, como o `{geobr}` e o `{aopdata}`. Nesse exemplo, vamos baixar o shapefile dos municípios mineiros usando o `{geobr}`:\n```{r}\n#| label: download-shp\n\nshp_mg_muni <- read_municipality(\n  code_muni = \"MG\",\n  showProgress = FALSE\n)\n```\n\nSegundo o manual da função `read_municipality()` (digite `?read_municipality` no console ou vá em `Help` e digite o nome da função), podemos baixar só os municípios de um estado especificando o código do estado ou sua sigla em `code_muni`, ou ainda baixar apenas uma cidade especificando o seu código de 7 dígitos do IBGE.\n\nAdicionei, ainda, `showProgress = FALSE` para não mostrar o status do download enquanto baixa. Outra opção é `simplified = FALSE` para baixar o shapefile mais detalhado possível. Isso é muito mais pesado; na dúvida, não baixe.\n\n:::{.callout-info}\nÀs vezes, um shapefile \"dá pau\" na hora de fazer as operações que vamos ver lá na frente. Se isso acontecer, use a transformação `st_make_valid()` para consertá-lo:\n:::\n\n```{r}\n#| label: make-valid\n\nshp_mg_muni <- shp_mg_muni %>% \n  st_make_valid()\n```\n\n\n### Do computador\n\nNeste exemplo, vamos carregar dois shapefiles para fazer operações espaciais: a malha de municípios mineiros, no formato `.shp`, e um mapa ferroviário, no formato do Google Earth (`.kml`). Usando o pacote `{sf}`, carregamos os shapefiles com `st_read()`. Supondo que você tem uma pasta chamada `shp` dentro da pasta `data` com seus shapefiles:\n\n```{r}\n#| label: read-mg\n#| eval: false\n\nshp_mg_muni <- here(\"data/shp/shapefile_minas.shp\") %>% \n  st_read()\n```\n\n::: {.callout-warning}\nOs shapefiles do tipo `.shp` tem pelo menos quatro camadas, em arquivos separados: `.dbf`, `.prj`, `.shp` e `.shx`. Por mais que na função `st_read()` nós passemos só o `.shp`, ela está usando todas as camadas; logo, elas devem estar na pasta também! \n:::\n\n```{r}\n#| label: read-ferro-background\n#| echo: false\n\nshp_ferrovias <- here(\"posts/2023-06-21-rotina-spatial/data/shp/ferrovias.kml\") %>% \n  st_read()\n```\n\n```{r}\n#| label: read-ferro\n#| eval: false\n\nshp_ferrovias <- here(\"data/shp/ferrovias.kml\") %>% \n  st_read()\n```\n\n::: {.fallout-info}\nNo Quarto (`.qmd`) e no RMarkdown (`.Rmd`), usamos a função `here()` do pacote homônimo para passar endereços relativos. Isso evita a bagunça que acontece com a dupla `setwd()`/`getwd()` e a chatice de ficar invertendo barras nos caminhos absolutos. Os endereços relativos são *relativos* à pasta origem do seu projeto, porque o R Project entende qur você está partindo dali.\n:::\n\n\n### Compatibilidade de coordenadas\n\nExistem diferentes padrões de coordenadas (**CRS**, de *Coordinate Reference System*): o mais comum é o WGS 84, usado nos GPS e no Google Maps. Mas, como a terra não é plana, alguns padrões são mais adequados para locais diferentes. No Brasil, mapas administrativos costumam usar o Sirgas 2000 e suas variantes. Por isso, temos ficar atentos se nossos shapefiles estão no mesmo padrão! Para verificar:\n\n```{r}\n#| label: check-crs\n\nst_crs(shp_mg_muni)\nst_crs(shp_ferrovias)\n```\n\nNesse exemplo, a malha municipal usa o Sirgas 2000, enquanto o mapa de ferrovias usa o WGS 84. Como eu prefiro o primeiro CRS, vou transformar o seguno para que também fique em Sirgas 2000. \n\n::: {.callout-tip}\nCada CRS tem um código **EPSG** associado. No caso do Sirgas 2000 é o 4674, e para o WGS 84, é o 4326. Veja mais em [epsg.io](https://epsg.io/).\n:::\n\n```{r}\n#| label: set-crs\n\n# Alternativa 1: modificar manualmente inserindo o CRS desejado.\nshp_ferrovias <- shp_ferrovias %>% \n  st_transform(crs = 4674)\n\n# Alternativa 2: modificar o CRS de X para que seja igual ao de Y.\nshp_ferrovias <- shp_ferrovias %>% \n  st_transform(crs = st_crs(shp_mg_muni))\n```\n\n\n\n## Filtrar shapefiles\n\nSuponha que queremos filtrar as cidades que são atravessadas por algumas ferrovias. Podemos fazer isso com o `st_filter()`. Mas antes, um resumo sobre as operações espaciais:\n\nO pacte `{sf}` contém uma série de funções que computam relações topológicas entre objetos espaciais (da classe `simple.feature`). Por exemplo: `st_intersects(x,y)` indica se `x` cruza `y`; `st_covers(x,y)`, se `x` cobre `y` e o contrário por `st_covered_by(x,y)` e assim em diante. Leia mais sobre essas operações no excelente [livro do Robin Lovelace](https://r.geocompx.org/geometry-operations.html) e no site do [PostGIS](http://postgis.net/workshops/postgis-intro/spatial_relationships.html), pois as operações realizadas em SQL são basicamente as mesmsas que o `{sf}` faz no `R`.\n\nEssas operações espaciais também podem ser usadas como predicado para filtrar ou juntar dados. Nesse exemplo, vamos usar o predicado `st_intersects`:\n```{r}\nshp_muni_ferro <- shp_mg_muni %>% \n  st_filter(shp_ferrovias, .predicate = st_intersects)\n```\n\nO novo objeto contém 190 municípios: apenas aqueles atravessados pelas ferrovias contidas no `.kml`. Alternativamente, podemos só salvar o novo objeto em cima do antigo: `shp_mg_muni <- shp_mg_muni %>% (...)`\n\n\n\n## Combinar bases\n\nOutra operação poderosa no R é combinar informações de uma base com um shapefile. Nesse exemplo, vamos usar uma base de população municipal do IBGE para cruzar com o shapefile de cidades mineiras. \n\n\n### Baixando dados do IBGE com o SidraR\n\nO Sidra ---Sistema IBGE de Recuperação Automática--- pode ser acessado diretamente pelo R. Você pode tanto buscar termos específicos, usando `search_sidra(\"termo\")`, quanto baixar diretamente uma tabela que você já conheça. Vamos usar o exemplo completo: vou buscar informações sobre população.\n\n```{r}\n#| label: search_sidra\n#| eval: false\n\nsearch_sidra(\"população\")\n```\n\nO resultado retornou mais de 90 tabelas. Como isso é muito confuso, prefiro ir no site do Sidra, ver a tabela que eu quero e baixar no R. No caso, quero a tabela `6579`. Vamos ver as opções disponíveis para ela:\n\n```{r}\n#| label: info_sidra\n\ninfo_sidra(6579)\n```\n\nDe posse dessas informações, podemos configurar a chamada da função `get_sidra()`:\n\n```{r}\n#| label: get_sidra\n\ndf_pop <- get_sidra(\n  6579,\n  period = \"2021\",\n  geo = \"City\"\n)\n\nglimpse(df_pop)\n```\n\nE assim, baixamos a população de 2021 para todos os municípios brasileiros. No entanto, essa tabela do IBGE não está organizada da melhor forma pra processamento no R. Podemos melhorar removendo as informações desnecessárias (`select()`) e limpando os nomes (`clean_names()` e `rename()`) para compatibilizar com a outra tabela.\n\n::: {.callout-tip}\nUse os mesmos nomes para variáveis comuns nos dois objetos. Não é obrigatório, mas facilita sua vida; caso contrário, tem que especificar qual variável de `x` é igual a qual variável de `y` para dar o join. Como o shapefile do `{geobr}` vem com nomes padronizados, vamos adotá-la e modificar a base do IBGE.  \n:::\n\n```{r}\n#| label: tidy-data\n\n# passo 1: limpar nomes (tirar maiúsculas, espaços e outras complicações)\ndf_pop <- df_pop %>% \n  clean_names() \n\n# passo 2: remover o que não precismos e renomear. Fazemos isso tudo junto com transmute, na sintaxe novo_nome = nome_antigo\ndf_pop <- df_pop %>% \n  transmute(\n    pop = valor, code_muni = as.numeric(municipio_codigo),\n    year = as.numeric(ano)\n  )\n```\n\nAo usarmos transmute, estamos ao mesmo tempo renomeando as variáveis que querendo e removendo as que não estão ali. Note que também passei `as.numeric()` em `code_muni` e `ano`, pois estavam como `character.` No caso de `code_muni`, essa informação é numérica (`numeric`) na base do `{geobr}`, então ia dar erro no join; já no caso do ano, é porque facilita quando esse tipo de informação é numérica (por exemplo, para filtrar datas maiores do que `x`).\n\n::: {.callout-warning}\nA informação de nome do município **frequentemente** está diferente entre bases. Ex.: acentuação, hifens, etc. Para não dar erro, prefira **SEMPRE** usar o código em vez do nome; repare que até removi o nome da cidade e vou usar apenas o do `{geobr}`. Nesse caso, a base do IBGE tem a sigla do estado junto do nome do município, como \"Abadia dos Dourados - MG\".\n:::\n\n\n### Juntando: população e shapefile\n\nAgora é partir para o abraço. Vamos jogar as informações do IBGE no shapefile ---ou vice-versa; nesse caso (não é sempre), a ordem não importa.\n\n```{r}\n#| label: join\n\nshp_mg_muni <- shp_mg_muni %>% \n  left_join(df_pop)\n```\n\n\n\n## Visualização\n\n### Mapa de municípios e população\n\nVamos plotar o mapa de Minas Gerais, colorindo de acordo com a população.\n\n```{r}\n#| label: basic-plot\n\nggplot() +\n  geom_sf(\n    data = shp_mg_muni,\n    aes(fill = pop)\n  )\n```\n\nPodemos customizar esse mapa adiconando camadas e capadas. As duas mais importantes: uma camada para a escala de cores do `fill` (preenchimento) e outra para o tema.\n\nExistem duas coleções de paletas muito famosas: Brewer e Viridis. A primeira tem cores mais \"comuns\", mas a segunda dá um contraste muito bom. Abaixo, as paletas de cada coleção e a sintaxe (substitua `XXX` pelo tipo de `aesthetic` em uso: `fill`, `color` etc.)\n\n* Brewer: https://r-graph-gallery.com/38-rcolorbrewers-palettes.html\n  + Discreta: `ggplot() + (...) + scale_XXX_brewer()`\n  + Condtínua: `ggplot() + (...) + scale_XXX_distiller()`\n  + Binned: `ggplot() + (...) + scale_XXX_fermenter()`\n* Viridis: https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html\n  + Discreta: `ggplot() + (...) + scale_XXX_viridis_d()`\n  + Condtínua: `ggplot() + (...) + scale_XXX_viridis_c()`\n  + Binned: `ggplot() + (...) + scale_XXX_viridis_b()`\n\nExemplo com viridis\n```{r}\n#| label: cool-plot-viridis\n\nggplot() +\n  geom_sf(\n    data = shp_mg_muni,\n    aes(fill = pop),\n    color = \"lightgrey\"\n  ) +\n  scale_fill_viridis_c(\n    option = \"magma\",\n    direction = -1,\n    name = \"População\", \n    labels = scales::comma_format(big.mark = \" \", decimal.mark = \",\")\n  ) +\n  labs(\n    title = \"População dos municípios mineiros em 2021\",\n    caption = \"Fonte: IBGE (2023)\"\n  ) +\n  theme_void()\n```\n\nExemplo com Brewer:\n```{r}\n#| label: cool-plot-brewer\n\nggplot() +\n  geom_sf(\n    data = shp_mg_muni,\n    aes(fill = pop),\n    color = \"lightgrey\"\n  ) +\n  scale_fill_distiller(\n    palette = \"YlGnBu\",\n    direction = 1,\n    name = \"População\", \n    labels = scales::comma_format(big.mark = \" \", decimal.mark = \",\")\n  ) +\n  labs(\n    title = \"População dos municípios mineiros em 2021\",\n    caption = \"Fonte: IBGE (2023)\"\n  ) +\n  theme_void()\n```\n\n#### Melhorando o mapa\n\nDe cara, eu acho que podemos melhorar esse mapa de duas formas: \n\n1. A escala não é muito útil. Temos só uma cidade com mais de 1 milhão de habitantes e só 4 com mais de 500 mil, então uma escala `binned` pode ser mais útil do que uma contínua. \n2. A às vezes os limites municipais mais poluem do que ajudam. Nesse caso, eu gosto de definir `color = NA` ou deixar `color` na mesma escala do `fill`. \n  + Vai depender do tamanho da sua malha e da precisão dos shapefiles: se ficar um vazio esquisito entre um polígono e outro, unifique color e fill.\n\nPrimeiro, vamos definir os argumentos de `scale_...` do lado de fora, para aplicar no `fill` e no `color` de forma unificada e diminuir o risco de erro humano. Nesse processo, vamos definir os `breaks` meio no olho, mas se quiser você pode usar quantis. Escolhi os valores abaixo vendo o que ficava melhor no mapa, tentando criar um equilíbrio de forma que permita distinguir as disparidades regionais, mas sem prejudicar muito o conforto visual. Para usar quantis, é só usar em `breaks` a função `quantile(x, probs = seq(0,1, p))` em que `x` é a variável sendo quantificada (no caso, `pop`) e definimos o vetor de probabilidades como sendo a sequência de 0 a 1 de p em p. Por exemplo: para quartis, p = 0,25; para decis, p = 0,10 e assim por diante.\n\n```{r}\n#| label: scale-args\n\nscale_args <- list(\n  palette = \"YlGnBu\",\n    direction = 1,\n    name = \"População\", \n    labels = scales::comma_format(big.mark = \" \", decimal.mark = \",\"),\n    breaks = c(5000, 25000, 50000, 100000, 250000, 500000, 2500000)\n)\n```\n\nAgora, precisamos de um pouco de atenção: salvamos os argumentos numa lista e para usá-los na escala, usamos a função `do.call(f,x)`, que faz uma chamada `call` à função `f()` usando os argumentos de `x`:\n```{r}\n#| label: coolest-plot-brewer\n\nggplot() +\n  geom_sf(\n    data = shp_mg_muni,\n    aes(fill = pop, color = pop)) +\n  do.call(scale_fill_fermenter, scale_args) +\n  do.call(scale_color_fermenter, scale_args) +\n  labs(\n    title = \"População dos municípios mineiros em 2021\",\n    caption = \"Fonte: IBGE (2023)\"\n  ) +\n  theme_void()\n```\n\n### Mapa de municípios e ferrovias\n\n```{r}\n#| label: ferro-plot\n\nshp_br <- read_state(showProgress = F)\n\nggplot() +\n  geom_sf(\n    data = shp_br %>% filter(abbrev_state != \"MG\"),\n    fill = \"grey85\",\n    color = \"grey60\"\n  ) +\n  geom_sf(\n    data = shp_mg_muni,\n    fill = \"grey95\",\n    color = \"grey90\"\n  ) + \n  geom_sf(\n    data = shp_ferrovias %>% filter(Name %in% c(\"BH - Nova Era\", \"Nova Era - Pedro Nolasco\")),\n    aes(color = \"EFVM\", linetype = \"Operando\")\n  ) +\n  geom_sf(\n    data = shp_ferrovias %>% filter(Name %in% c(\"Horto - Salvador\", \"Corinto - Pirapora\")),\n    aes(color = \"FCA\", linetype = \"Operando\")\n  ) +\n  geom_sf(\n    data = shp_ferrovias %>% filter(Name == \"Horto - Itabirito\"),\n    aes(color = \"FdA\", linetype = \"Obra abandonada\")\n  ) +\n  geom_sf(\n    data = shp_ferrovias %>% filter(Name == \"Itabirito - Rio\"),\n    aes(color = \"FdA\", linetype = \"Operando\")\n  ) +\n  scale_color_manual(\n    values = c(\"EFVM\" = \"#3cc954\", \"FCA\" = \"#60a8f6\", \"FdA\" = \"#2a4ea1\"),\n    name = \"Ferrovia\"\n  ) +\n  scale_linetype_manual(\n    values = c(\"Operando\" = \"solid\", \"Obra abandonada\" = \"dashed\"),\n    name = \"Status\"\n  ) +\n  labs(\n    title = \"Minas Gerais: algumas ferrovias\"\n  ) +\n  geom_sf_text(\n    data = shp_mg_muni %>% filter(code_muni %in% c(3106200, 3136702, 3127701, 3143302)),\n    aes(label = name_muni),\n    hjust = 1,\n    size = 2.5\n  ) +\n  xlim(-50.75, -40.25) +\n  ylim(-22.75, -14.5) +\n  theme_void() +\n  theme(\n    panel.background = element_rect(fill = \"skyblue\", color = NA)\n  )\n```\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":"fenced","output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"include-in-header":{"text":"<style>\nh1 {\ncolor: #fff;\n}\n</style>\n"},"output-file":"index.html"},"language":{"toc-title-document":"Índice","toc-title-website":"Nesta página","related-formats-title":"Outros formatos","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Fonte","section-title-abstract":"Resumo","section-title-appendices":"Apêndices","section-title-footnotes":"Notas de rodapé","section-title-references":"Referências","section-title-reuse":"Reuso","section-title-copyright":"Direito autoral","section-title-citation":"Citação","appendix-attribution-cite-as":"Por favor, cite este trabalho como:","appendix-attribution-bibtex":"BibTeX","title-block-author-single":"Autor","title-block-author-plural":"Autores","title-block-affiliation-single":"Afiliação","title-block-affiliation-plural":"Afiliações","title-block-published":"Data de Publicação","title-block-modified":"Data de Modificação","callout-tip-title":"Dica","callout-note-title":"Nota","callout-warning-title":"Aviso","callout-important-title":"Importante","callout-caution-title":"Cuidado","code-summary":"Código","code-tools-menu-caption":"Código","code-tools-show-all-code":"Mostrar o código","code-tools-hide-all-code":"Esconder o código","code-tools-view-source":"Ver o código fonte","code-tools-source-code":"Código fonte","code-line":"Linha","code-lines":"Linhas","copy-button-tooltip":"Copiar para a área de transferência","copy-button-tooltip-success":"Copiada","repo-action-links-edit":"Editar essa página","repo-action-links-source":"Ver o código fonte","repo-action-links-issue":"Criar uma issue","back-to-top":"De volta ao topo","search-no-results-text":"Nenhum resultado","search-matching-documents-text":"documentos correspondentes","search-copy-link-title":"Copiar link para a busca","search-hide-matches-text":"Esconder correspondências adicionais","search-more-match-text":"mais correspondência neste documento","search-more-matches-text":"mais correspondências neste documento","search-clear-button-title":"Limpar","search-detached-cancel-button-title":"Cancelar","search-submit-button-title":"Enviar","search":"Procurar","toggle-section":"Alternar seção","toggle-sidebar":"Alternar barra lateral","toggle-dark-mode":"Alternar modo escuro","toggle-reader-mode":"Alternar modo de leitor","toggle-navigation":"Alternar de navegação","crossref-fig-title":"Figura","crossref-tbl-title":"Tabela","crossref-lst-title":"Listagem","crossref-thm-title":"Teorema","crossref-lem-title":"Lema","crossref-cor-title":"Corolário","crossref-prp-title":"Proposição","crossref-cnj-title":"Conjectura","crossref-def-title":"Definição","crossref-exm-title":"Exemplo","crossref-exr-title":"Exercício","crossref-ch-prefix":"Capítulo","crossref-apx-prefix":"Apêndice","crossref-sec-prefix":"Seção","crossref-eq-prefix":"Equação","crossref-lof-title":"Lista de Figuras","crossref-lot-title":"Lista de Tabelas","crossref-lol-title":"Lista de Listagens","environment-proof-title":"Comprovação","environment-remark-title":"Comentário","environment-solution-title":"Solução","listing-page-order-by":"Ordenar por","listing-page-order-by-default":"Pré-selecionado","listing-page-order-by-date-asc":"Mais velho","listing-page-order-by-date-desc":"O mais novo","listing-page-order-by-number-desc":"Decrescente","listing-page-order-by-number-asc":"Crescente","listing-page-field-date":"Data","listing-page-field-title":"Título","listing-page-field-description":"Descrição","listing-page-field-author":"Autor","listing-page-field-filename":"Nome do arquivo","listing-page-field-filemodified":"Arquivo modificado","listing-page-field-subtitle":"Subtítulo","listing-page-field-readingtime":"Tempo de leitura","listing-page-field-categories":"Categorias","listing-page-minutes-compact":"{0} minutos","listing-page-category-all":"Tudo","listing-page-no-matches":"Nenhum item correspondente"},"metadata":{"lang":"pt-BR","fig-responsive":true,"quarto-version":"1.4.60","comments":{"giscus":{"repo":"baarthur/baarthur.github.io"}},"theme":{"light":["flatly","../../styles.scss"],"dark":["darkly","../../styles.scss"]},"mainfont":"Atkinson Hyperlegible","title-block-banner":true,"title":"Rotina espacial no R","description":"Aprenda a baixar, filtrar e combinar dados","author":[{"name":"Arthur Bazolli Alvarenga","url":"https://baarthur.github.io/","affiliation":"PPGE/UFJF","affiliation-url":"https://www2.ufjf.br/poseconomia/"}],"date":"2023-06-21","categories":["R","r-spatial","Geocomputação","Tutorial"],"citation":{"url":"https://baarthur.github.io/posts/2023-06-20-rotina-spatial/"},"image":"thumbnail.png","draft":false},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}